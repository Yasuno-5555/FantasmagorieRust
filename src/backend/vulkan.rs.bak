//! Vulkan backend - Native Vulkan rendering via ash
//!
//! Full implementation using ash crate for Vulkan 1.2+ support.
//! Targets: Windows (Vulkan), Linux (Vulkan), Android (Vulkan)

use crate::core::{ColorF, Vec2};
use crate::draw::{DrawCommand, DrawList};
use ash::vk;
use std::ffi::CStr;

/// Vulkan-based rendering backend
pub struct VulkanBackend {
    _entry: ash::Entry,
    instance: ash::Instance,
    physical_device: vk::PhysicalDevice,
    device: ash::Device,
    graphics_queue: vk::Queue,
    command_pool: vk::CommandPool,
    command_buffer: vk::CommandBuffer,
    render_pass: vk::RenderPass,
    render_pass_load: vk::RenderPass,
    pipeline_layout: vk::PipelineLayout,
    pipeline: vk::Pipeline,
    descriptor_set_layout: vk::DescriptorSetLayout,
    descriptor_pool: vk::DescriptorPool,

    // Swapchain
    surface_loader: ash::khr::surface::Instance,
    swapchain_loader: ash::khr::swapchain::Device,
    surface: vk::SurfaceKHR,
    swapchain: vk::SwapchainKHR,
    swapchain_images: Vec<vk::Image>,
    swapchain_image_views: Vec<vk::ImageView>,
    framebuffers: Vec<vk::Framebuffer>,

    // Buffers
    vertex_buffer: vk::Buffer,
    vertex_memory: vk::DeviceMemory,
    uniform_buffer: vk::Buffer,
    uniform_memory: vk::DeviceMemory,

    // Texture
    font_texture: vk::Image,
    font_texture_memory: vk::DeviceMemory,
    font_texture_view: vk::ImageView,
    sampler: vk::Sampler,
    descriptor_set: vk::DescriptorSet,

    // Sync
    image_available_semaphore: vk::Semaphore,
    render_finished_semaphore: vk::Semaphore,
    in_flight_fence: vk::Fence,

    // Compute Pipelines (Aggressive Plan)
    k13_pipeline: vk::Pipeline,
    k13_layout: vk::PipelineLayout,
    k8_pipeline: vk::Pipeline,
    k8_layout: vk::PipelineLayout,
    k6_update_pipeline: vk::Pipeline,
    k6_spawn_pipeline: vk::Pipeline,
    k6_layout: vk::PipelineLayout,
    k5_pipeline: vk::Pipeline,
    k5_layout: vk::PipelineLayout,
    k4_pipeline: vk::Pipeline,
    k4_layout: vk::PipelineLayout,

    k13_descriptor_set: vk::DescriptorSet,
    k8_descriptor_set: vk::DescriptorSet,
    k6_descriptor_set: vk::DescriptorSet,
    k5_descriptor_sets: [vk::DescriptorSet; 2],
    k4_descriptor_set: vk::DescriptorSet,

    // Compute Storage Buffers
    indirect_dispatch_buffer: vk::Buffer,
    indirect_dispatch_memory: vk::DeviceMemory,
    indirect_draw_buffer: vk::Buffer,
    indirect_draw_memory: vk::DeviceMemory,
    counter_buffer: vk::Buffer,
    counter_memory: vk::DeviceMemory,
    instance_buffer: vk::Buffer,
    instance_memory: vk::DeviceMemory,
    particle_buffer: vk::Buffer,
    particle_memory: vk::DeviceMemory,
    counter_readback_buffer: vk::Buffer,
    counter_readback_memory: vk::DeviceMemory,

    width: u32,
    height: u32,
    start_time: std::time::Instant,
    last_image_index: u32,

    // Backdrop for blur
    backdrop_image: vk::Image,
    backdrop_memory: vk::DeviceMemory,
    backdrop_view: vk::ImageView,

    // JFA SDF Lighting (K5)
    jfa_images: [(vk::Image, vk::DeviceMemory, vk::ImageView); 2],
    sdf_image: (vk::Image, vk::DeviceMemory, vk::ImageView),
    jfa_framebuffers: [vk::Framebuffer; 2],
    seed_render_pass: vk::RenderPass,
    seed_pipeline: vk::Pipeline,
    seed_layout: vk::PipelineLayout,
    k5_resolve_pipeline: vk::Pipeline,
    k5_resolve_layout: vk::PipelineLayout,
    k5_resolve_descriptor_sets: [vk::DescriptorSet; 2],

    // Profiling
    query_pools: [vk::QueryPool; 2],
    timestamp_period: f32,
    frame_index: usize,
}

/// Vertex format for Vulkan
#[repr(C)]
#[derive(Copy, Clone, Debug)]
struct Vertex {
    pos: [f32; 2],
    uv: [f32; 2],
    color: [f32; 4],
}

/// Push constants for per-draw data (Matches DrawUniforms in shaders)
#[repr(C)]
#[derive(Copy, Clone, Debug)]
struct PushConstants {
    rect: [f32; 4],
    radii: [f32; 4],
    border_color: [f32; 4],
    glow_color: [f32; 4],
    offset: [f32; 2],
    scale: f32,
    border_width: f32,
    elevation: f32,
    glow_strength: f32,
    lut_intensity: f32,
    mode: u32,
    is_squircle: u32,
    _pad: [u32; 1],
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
struct JFAUniforms {
    width: u32,
    height: u32,
    step: u32,
    ping_pong_idx: u32,
}

/// Uniform buffer for global data (Matches GlobalUniforms in shaders)
#[repr(C)]
#[derive(Copy, Clone, Debug)]
struct UniformBufferObject {
    projection: [[f32; 4]; 4],
    viewport: [f32; 2],
    time: f32,
    _pad: f32,
}

impl VulkanBackend {
    /// Create a new Vulkan backend
    ///
    /// # Safety
    /// Requires valid window handle for surface creation
    #[cfg(target_os = "windows")]
    pub unsafe fn new(
        hwnd: *mut std::ffi::c_void,
        hinstance: *mut std::ffi::c_void,
        width: u32,
        height: u32,
    ) -> Result<Self, String> {
        // Load Vulkan
        let entry = ash::Entry::load().map_err(|e| format!("Failed to load Vulkan: {:?}", e))?;

        // Create instance
        let app_name = std::ffi::CString::new("Fantasmagorie").unwrap();
        let engine_name = std::ffi::CString::new("Fantasmagorie Engine").unwrap();

        let app_info = vk::ApplicationInfo::default()
            .application_name(app_name.as_ptr())
            .application_version(vk::make_api_version(0, 1, 0, 0))
            .engine_name(engine_name.as_ptr())
            .engine_version(vk::make_api_version(0, 1, 0, 0))
            .api_version(vk::API_VERSION_1_2);

        let extension_names = [
            ash::khr::surface::NAME.as_ptr(),
            ash::khr::win32_surface::NAME.as_ptr(),
        ];

        let create_info = vk::InstanceCreateInfo::default()
            .application_info(&app_info)
            .enabled_extension_names(&extension_names);

        let instance = entry
            .create_instance(&create_info, None)
            .map_err(|e| format!("Failed to create Vulkan instance: {:?}", e))?;

        println!("âœ… Vulkan instance created");

        // Create Win32 surface
        let win32_surface_loader = ash::khr::win32_surface::Instance::new(&entry, &instance);
        let surface_create_info = vk::Win32SurfaceCreateInfoKHR::default()
            .hinstance(hinstance as vk::HINSTANCE)
            .hwnd(hwnd as vk::HWND);

        let surface = win32_surface_loader
            .create_win32_surface(&surface_create_info, None)
            .map_err(|e| format!("Failed to create Win32 surface: {:?}", e))?;

        let surface_loader = ash::khr::surface::Instance::new(&entry, &instance);

        // Select physical device
        let physical_devices = instance
            .enumerate_physical_devices()
            .map_err(|e| format!("Failed to enumerate physical devices: {:?}", e))?;

        let physical_device = physical_devices
            .into_iter()
            .find(|&pd| {
                let props = instance.get_physical_device_properties(pd);
                props.device_type == vk::PhysicalDeviceType::DISCRETE_GPU
                    || props.device_type == vk::PhysicalDeviceType::INTEGRATED_GPU
            })
            .ok_or("No suitable GPU found")?;

        let props = instance.get_physical_device_properties(physical_device);
        let device_name = CStr::from_ptr(props.device_name.as_ptr()).to_string_lossy();
        println!("ðŸŽ® Vulkan device: {}", device_name);

        // Find graphics queue family
        let queue_families = instance.get_physical_device_queue_family_properties(physical_device);
        let graphics_family = queue_families
            .iter()
            .position(|qf| qf.queue_flags.contains(vk::QueueFlags::GRAPHICS))
            .ok_or("No graphics queue family found")? as u32;

        // Create logical device
        let queue_priorities = [1.0f32];
        let queue_create_info = vk::DeviceQueueCreateInfo::default()
            .queue_family_index(graphics_family)
            .queue_priorities(&queue_priorities);

        let device_extensions = [ash::khr::swapchain::NAME.as_ptr()];

        let device_create_info = vk::DeviceCreateInfo::default()
            .queue_create_infos(std::slice::from_ref(&queue_create_info))
            .enabled_extension_names(&device_extensions);

        let device = instance
            .create_device(physical_device, &device_create_info, None)
            .map_err(|e| format!("Failed to create logical device: {:?}", e))?;

        let graphics_queue = device.get_device_queue(graphics_family, 0);

        // Create swapchain
        let swapchain_loader = ash::khr::swapchain::Device::new(&instance, &device);

        let surface_caps = surface_loader
            .get_physical_device_surface_capabilities(physical_device, surface)
            .map_err(|e| format!("Failed to get surface capabilities: {:?}", e))?;

        let surface_format = vk::SurfaceFormatKHR {
            format: vk::Format::B8G8R8A8_SRGB,
            color_space: vk::ColorSpaceKHR::SRGB_NONLINEAR,
        };

        let swapchain_create_info = vk::SwapchainCreateInfoKHR::default()
            .surface(surface)
            .min_image_count(2)
            .image_format(surface_format.format)
            .image_color_space(surface_format.color_space)
            .image_extent(vk::Extent2D { width, height })
            .image_array_layers(1)
            .image_usage(vk::ImageUsageFlags::COLOR_ATTACHMENT | vk::ImageUsageFlags::TRANSFER_SRC)
            .image_sharing_mode(vk::SharingMode::EXCLUSIVE)
            .pre_transform(surface_caps.current_transform)
            .composite_alpha(vk::CompositeAlphaFlagsKHR::OPAQUE)
            .present_mode(vk::PresentModeKHR::FIFO)
            .clipped(true);

        let swapchain = swapchain_loader
            .create_swapchain(&swapchain_create_info, None)
            .map_err(|e| format!("Failed to create swapchain: {:?}", e))?;

        let swapchain_images = swapchain_loader
            .get_swapchain_images(swapchain)
            .map_err(|e| format!("Failed to get swapchain images: {:?}", e))?;

        // Create image views
        let swapchain_image_views: Vec<vk::ImageView> = swapchain_images
            .iter()
            .map(|&image| {
                let create_info = vk::ImageViewCreateInfo::default()
                    .image(image)
                    .view_type(vk::ImageViewType::TYPE_2D)
                    .format(surface_format.format)
                    .components(vk::ComponentMapping {
                        r: vk::ComponentSwizzle::IDENTITY,
                        g: vk::ComponentSwizzle::IDENTITY,
                        b: vk::ComponentSwizzle::IDENTITY,
                        a: vk::ComponentSwizzle::IDENTITY,
                    })
                    .subresource_range(vk::ImageSubresourceRange {
                        aspect_mask: vk::ImageAspectFlags::COLOR,
                        base_mip_level: 0,
                        level_count: 1,
                        base_array_layer: 0,
                        layer_count: 1,
                    });
                device.create_image_view(&create_info, None).unwrap()
            })
            .collect();

        // Create render pass
        let attachment = vk::AttachmentDescription::default()
            .format(surface_format.format)
            .samples(vk::SampleCountFlags::TYPE_1)
            .load_op(vk::AttachmentLoadOp::CLEAR)
            .store_op(vk::AttachmentStoreOp::STORE)
            .stencil_load_op(vk::AttachmentLoadOp::DONT_CARE)
            .stencil_store_op(vk::AttachmentStoreOp::DONT_CARE)
            .initial_layout(vk::ImageLayout::UNDEFINED)
            .final_layout(vk::ImageLayout::PRESENT_SRC_KHR);

        let attachment_ref = vk::AttachmentReference::default()
            .attachment(0)
            .layout(vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL);

        let subpass = vk::SubpassDescription::default()
            .pipeline_bind_point(vk::PipelineBindPoint::GRAPHICS)
            .color_attachments(std::slice::from_ref(&attachment_ref));

        let render_pass_info = vk::RenderPassCreateInfo::default()
            .attachments(std::slice::from_ref(&attachment))
            .subpasses(std::slice::from_ref(&subpass));

        let render_pass = device
            .create_render_pass(&render_pass_info, None)
            .map_err(|e| format!("Failed to create render pass: {:?}", e))?;

        // Create render pass (Load)
        let attachment_load = vk::AttachmentDescription::default()
            .format(surface_format.format)
            .samples(vk::SampleCountFlags::TYPE_1)
            .load_op(vk::AttachmentLoadOp::LOAD) // CONTINUE
            .store_op(vk::AttachmentStoreOp::STORE)
            .stencil_load_op(vk::AttachmentLoadOp::DONT_CARE)
            .stencil_store_op(vk::AttachmentStoreOp::DONT_CARE)
            .initial_layout(vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL)
            .final_layout(vk::ImageLayout::PRESENT_SRC_KHR);

        let render_pass_info_load = vk::RenderPassCreateInfo::default()
            .attachments(std::slice::from_ref(&attachment_load))
            .subpasses(std::slice::from_ref(&subpass));

        let render_pass_load = device
            .create_render_pass(&render_pass_info_load, None)
            .map_err(|e| format!("Failed to create render pass load: {:?}", e))?;

        // Create framebuffers
        let framebuffers: Vec<vk::Framebuffer> = swapchain_image_views
            .iter()
            .map(|&view| {
                let attachments = [view];
                let create_info = vk::FramebufferCreateInfo::default()
                    .render_pass(render_pass)
                    .attachments(&attachments)
                    .width(width)
                    .height(height)
                    .layers(1);
                device.create_framebuffer(&create_info, None).unwrap()
            })
            .collect();

        // Create descriptor set layout
        let bindings = [
            vk::DescriptorSetLayoutBinding::default()
                .binding(0)
                .descriptor_type(vk::DescriptorType::UNIFORM_BUFFER)
                .descriptor_count(1)
                .stage_flags(vk::ShaderStageFlags::VERTEX | vk::ShaderStageFlags::FRAGMENT),
            vk::DescriptorSetLayoutBinding::default()
                .binding(1)
                .descriptor_type(vk::DescriptorType::SAMPLED_IMAGE) // Font Texture
                .descriptor_count(1)
                .stage_flags(vk::ShaderStageFlags::FRAGMENT),
            vk::DescriptorSetLayoutBinding::default()
                .binding(2)
                .descriptor_type(vk::DescriptorType::SAMPLER) // Universal Sampler
                .descriptor_count(1)
                .stage_flags(vk::ShaderStageFlags::FRAGMENT),
            vk::DescriptorSetLayoutBinding::default()
                .binding(3)
                .descriptor_type(vk::DescriptorType::SAMPLED_IMAGE) // LUT Texture
                .descriptor_count(1)
                .stage_flags(vk::ShaderStageFlags::FRAGMENT),
            vk::DescriptorSetLayoutBinding::default()
                .binding(4)
                .descriptor_type(vk::DescriptorType::SAMPLED_IMAGE) // Backdrop Texture
                .descriptor_count(1)
                .stage_flags(vk::ShaderStageFlags::FRAGMENT),
            vk::DescriptorSetLayoutBinding::default()
                .binding(5)
                .descriptor_type(vk::DescriptorType::STORAGE_BUFFER) // Instance Data
                .descriptor_count(1)
                .stage_flags(vk::ShaderStageFlags::VERTEX | vk::ShaderStageFlags::FRAGMENT),
        ];

        let layout_info = vk::DescriptorSetLayoutCreateInfo::default().bindings(&bindings);

        let descriptor_set_layout = device
            .create_descriptor_set_layout(&layout_info, None)
            .map_err(|e| format!("Failed to create descriptor set layout: {:?}", e))?;

        // Create pipeline layout with push constants
        let push_constant_range = vk::PushConstantRange::default()
            .stage_flags(vk::ShaderStageFlags::VERTEX | vk::ShaderStageFlags::FRAGMENT)
            .offset(0)
            .size(std::mem::size_of::<PushConstants>() as u32);

        let pipeline_layout_info = vk::PipelineLayoutCreateInfo::default()
            .set_layouts(std::slice::from_ref(&descriptor_set_layout))
            .push_constant_ranges(std::slice::from_ref(&push_constant_range));

        let pipeline_layout = device
            .create_pipeline_layout(&pipeline_layout_info, None)
            .map_err(|e| format!("Failed to create pipeline layout: {:?}", e))?;

        // Create command pool
        let pool_info = vk::CommandPoolCreateInfo::default()
            .queue_family_index(graphics_family)
            .flags(vk::CommandPoolCreateFlags::RESET_COMMAND_BUFFER);

        let command_pool = device
            .create_command_pool(&pool_info, None)
            .map_err(|e| format!("Failed to create command pool: {:?}", e))?;

        // Allocate command buffer
        let alloc_info = vk::CommandBufferAllocateInfo::default()
            .command_pool(command_pool)
            .level(vk::CommandBufferLevel::PRIMARY)
            .command_buffer_count(1);

        let command_buffers = device
            .allocate_command_buffers(&alloc_info)
            .map_err(|e| format!("Failed to allocate command buffers: {:?}", e))?;
        let command_buffer = command_buffers[0];

        // Create sync objects
        let semaphore_info = vk::SemaphoreCreateInfo::default();
        let fence_info = vk::FenceCreateInfo::default().flags(vk::FenceCreateFlags::SIGNALED);

        let image_available_semaphore = device
            .create_semaphore(&semaphore_info, None)
            .map_err(|e| format!("Failed to create semaphore: {:?}", e))?;
        let render_finished_semaphore = device
            .create_semaphore(&semaphore_info, None)
            .map_err(|e| format!("Failed to create semaphore: {:?}", e))?;
        let in_flight_fence = device
            .create_fence(&fence_info, None)
            .map_err(|e| format!("Failed to create fence: {:?}", e))?;

        // Create vertex buffer (dynamic, host visible)
        let buffer_size = 65536 * std::mem::size_of::<Vertex>() as vk::DeviceSize;
        let (vertex_buffer, vertex_memory) = Self::create_buffer(
            &device,
            &instance,
            physical_device,
            buffer_size,
            vk::BufferUsageFlags::VERTEX_BUFFER,
            vk::MemoryPropertyFlags::HOST_VISIBLE | vk::MemoryPropertyFlags::HOST_COHERENT,
        )?;

        // Create uniform buffer
        let uniform_size = std::mem::size_of::<UniformBufferObject>() as vk::DeviceSize;
        let (uniform_buffer, uniform_memory) = Self::create_buffer(
            &device,
            &instance,
            physical_device,
            uniform_size,
            vk::BufferUsageFlags::UNIFORM_BUFFER,
            vk::MemoryPropertyFlags::HOST_VISIBLE | vk::MemoryPropertyFlags::HOST_COHERENT,
        )?;

        // Allocate Compute Storage Buffers (Aggressive Plan)
        let (indirect_dispatch_buffer, indirect_dispatch_memory) = Self::create_buffer(
            &device,
            &instance,
            physical_device,
            1024, // 256 commands
            vk::BufferUsageFlags::STORAGE_BUFFER | vk::BufferUsageFlags::INDIRECT_BUFFER | vk::BufferUsageFlags::TRANSFER_DST,
            vk::MemoryPropertyFlags::DEVICE_LOCAL,
        )?;

        let (indirect_draw_buffer, indirect_draw_memory) = Self::create_buffer(
            &device,
            &instance,
            physical_device,
            1024, // 256 commands
            vk::BufferUsageFlags::STORAGE_BUFFER | vk::BufferUsageFlags::INDIRECT_BUFFER | vk::BufferUsageFlags::TRANSFER_DST,
            vk::MemoryPropertyFlags::DEVICE_LOCAL,
        )?;

        let (counter_buffer, counter_memory) = Self::create_buffer(
            &device,
            &instance,
            physical_device,
            1024, // 256 counters
            vk::BufferUsageFlags::STORAGE_BUFFER | vk::BufferUsageFlags::TRANSFER_DST | vk::BufferUsageFlags::TRANSFER_SRC,
            vk::MemoryPropertyFlags::DEVICE_LOCAL,
        )?;

        let (instance_buffer, instance_memory) = Self::create_buffer(
            &device,
            &instance,
            physical_device,
            1024 * 1024 * 4, // 4MB for instances
            vk::BufferUsageFlags::STORAGE_BUFFER | vk::BufferUsageFlags::TRANSFER_DST,
            vk::MemoryPropertyFlags::DEVICE_LOCAL,
        )?;

        let (particle_buffer, particle_memory) = Self::create_buffer(
            &device,
            &instance,
            physical_device,
            1024 * 1024 * 32, // 32MB for particles
            vk::BufferUsageFlags::STORAGE_BUFFER | vk::BufferUsageFlags::TRANSFER_DST,
            vk::MemoryPropertyFlags::DEVICE_LOCAL,
        )?;

        let (counter_readback_buffer, counter_readback_memory) = Self::create_buffer(
            &device,
            &instance,
            physical_device,
            1024,
            vk::BufferUsageFlags::TRANSFER_DST,
            vk::MemoryPropertyFlags::HOST_VISIBLE | vk::MemoryPropertyFlags::HOST_COHERENT,
        )?;

        // Create font texture (1024x1024 for atlas compatibility)
        let (font_texture, font_texture_memory, font_texture_view) = Self::create_texture(
            &device,
            &instance,
            physical_device,
            1024,
            1024,
            None,
            vk::Format::R8_UNORM,
            vk::ImageUsageFlags::TRANSFER_DST | vk::ImageUsageFlags::SAMPLED,
            1,
        )?;

        // Create backdrop image for blur
            6, // 6 mip levels for blur
        )?;

        // Create backdrop image for blur
        let (backdrop_image, backdrop_memory, backdrop_view) = Self::create_texture(
            &device,
            &instance,
            physical_device,
            width,
            height,
            None,
            vk::Format::B8G8R8A8_SRGB, // Match swapchain
            vk::ImageUsageFlags::TRANSFER_DST
                | vk::ImageUsageFlags::TRANSFER_SRC
                | vk::ImageUsageFlags::SAMPLED,
            6, // 6 mip levels for blur
        )?;

        // JFA SDF Lighting (K5) textures
        let jfa_images = [
            Self::create_texture(&device, &instance, physical_device, width, height, None, vk::Format::R32G32_SFLOAT, vk::ImageUsageFlags::STORAGE | vk::ImageUsageFlags::SAMPLED | vk::ImageUsageFlags::TRANSFER_DST, 1)?,
            Self::create_texture(&device, &instance, physical_device, width, height, None, vk::Format::R32G32_SFLOAT, vk::ImageUsageFlags::STORAGE | vk::ImageUsageFlags::SAMPLED | vk::ImageUsageFlags::TRANSFER_DST, 1)?,
        ];
        let sdf_image = Self::create_texture(&device, &instance, physical_device, width, height, None, vk::Format::R32_SFLOAT, vk::ImageUsageFlags::STORAGE | vk::ImageUsageFlags::SAMPLED | vk::ImageUsageFlags::TRANSFER_SRC, 1)?;

        // Create sampler
        let sampler_info = vk::SamplerCreateInfo::default()
            .mag_filter(vk::Filter::LINEAR)
            .min_filter(vk::Filter::LINEAR)
            .address_mode_u(vk::SamplerAddressMode::CLAMP_TO_EDGE)
            .address_mode_v(vk::SamplerAddressMode::CLAMP_TO_EDGE)
            .address_mode_w(vk::SamplerAddressMode::CLAMP_TO_EDGE);

        let sampler = device
            .create_sampler(&sampler_info, None)
            .map_err(|e| format!("Failed to create sampler: {:?}", e))?;

        // Create descriptor pool (Expanded for Compute)
        let pool_sizes = [
            vk::DescriptorPoolSize {
                ty: vk::DescriptorType::UNIFORM_BUFFER,
                descriptor_count: 10,
            },
            vk::DescriptorPoolSize {
                ty: vk::DescriptorType::SAMPLED_IMAGE,
                descriptor_count: 20,
            },
            vk::DescriptorPoolSize {
                ty: vk::DescriptorType::SAMPLER,
                descriptor_count: 10,
            },
            vk::DescriptorPoolSize {
                ty: vk::DescriptorType::STORAGE_BUFFER,
                descriptor_count: 20,
            },
            vk::DescriptorPoolSize {
                ty: vk::DescriptorType::STORAGE_IMAGE,
                descriptor_count: 10,
            },
        ];

        let pool_info = vk::DescriptorPoolCreateInfo::default()
            .pool_sizes(&pool_sizes)
            .max_sets(20);

        let descriptor_pool = device
            .create_descriptor_pool(&pool_info, None)
            .map_err(|e| format!("Failed to create descriptor pool: {:?}", e))?;

        // Allocate descriptor set
        let alloc_info = vk::DescriptorSetAllocateInfo::default()
            .descriptor_pool(descriptor_pool)
            .set_layouts(std::slice::from_ref(&descriptor_set_layout));

        let descriptor_sets = device
            .allocate_descriptor_sets(&alloc_info)
            .map_err(|e| format!("Failed to allocate descriptor sets: {:?}", e))?;
        let descriptor_set = descriptor_sets[0];

        // Update descriptor set
        let buffer_info = vk::DescriptorBufferInfo::default()
            .buffer(uniform_buffer)
            .offset(0)
            .range(uniform_size);

        let font_image_info = vk::DescriptorImageInfo::default()
            .image_view(font_texture_view)
            .image_layout(vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL);
            
        let sampler_info = vk::DescriptorImageInfo::default()
            .sampler(sampler);

        let backdrop_image_info = vk::DescriptorImageInfo::default()
            .image_view(backdrop_view)
            .image_layout(vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL);

        let instance_info = vk::DescriptorBufferInfo::default()
            .buffer(instance_buffer)
            .offset(0)
            .range(vk::WHOLE_SIZE);

        let writes = [
            vk::WriteDescriptorSet::default()
                .dst_set(descriptor_set)
                .dst_binding(0)
                .descriptor_type(vk::DescriptorType::UNIFORM_BUFFER)
                .buffer_info(std::slice::from_ref(&buffer_info)),
            vk::WriteDescriptorSet::default()
                .dst_set(descriptor_set)
                .dst_binding(1)
                .descriptor_type(vk::DescriptorType::SAMPLED_IMAGE)
                .image_info(std::slice::from_ref(&font_image_info)),
            vk::WriteDescriptorSet::default()
                .dst_set(descriptor_set)
                .dst_binding(2)
                .descriptor_type(vk::DescriptorType::SAMPLER)
                .image_info(std::slice::from_ref(&sampler_info)),
            vk::WriteDescriptorSet::default()
                .dst_set(descriptor_set)
                .dst_binding(3)
                .descriptor_type(vk::DescriptorType::SAMPLED_IMAGE)
                .image_info(std::slice::from_ref(&font_image_info)), // Use font as LUT placeholder
            vk::WriteDescriptorSet::default()
                .dst_set(descriptor_set)
                .dst_binding(4)
                .descriptor_type(vk::DescriptorType::SAMPLED_IMAGE)
                .image_info(std::slice::from_ref(&backdrop_image_info)),
            vk::WriteDescriptorSet::default()
                .dst_set(descriptor_set)
                .dst_binding(5)
                .descriptor_type(vk::DescriptorType::STORAGE_BUFFER)
                .buffer_info(std::slice::from_ref(&instance_info)),
        ];

        device.update_descriptor_sets(&writes, &[]);

        // Helper to compile WGSL to SPIR-V using Naga (much more stable for Vulkan push constants)
        fn compile_wgsl(src: &str) -> Result<Vec<u32>, String> {
            let module = naga::front::wgsl::parse_str(src)
                .map_err(|e| format!("WGSL Parse Error: {:?}", e))?;

            let info = naga::valid::Validator::new(
                naga::valid::ValidationFlags::all(),
                naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .map_err(|e| format!("Validation Error: {:?}", e))?;

            let mut options = naga::back::spv::Options::default();
            options.lang_version = (1, 0);

            let binary = naga::back::spv::write_vec(&module, &info, &options, None)
                .map_err(|e| format!("SPIR-V Write Error: {:?}", e))?;

            Ok(binary)
        }

        let wgsl_src = include_str!("vulkan.wgsl");
        let spv_binary = compile_wgsl(wgsl_src)?;

        // Create Modules
        let shader_code = vk::ShaderModuleCreateInfo::default().code(&spv_binary);
        let shader_module = unsafe {
            device
                .create_shader_module(&shader_code, None)
                .map_err(|e| format!("Failed to create shader module: {}", e))?
        };

        let vert_stage = vk::PipelineShaderStageCreateInfo::default()
            .stage(vk::ShaderStageFlags::VERTEX)
            .module(shader_module)
            .name(unsafe { CStr::from_bytes_with_nul_unchecked(b"vs_main\0") });

        let frag_stage = vk::PipelineShaderStageCreateInfo::default()
            .stage(vk::ShaderStageFlags::FRAGMENT)
            .module(shader_module)
            .name(unsafe { CStr::from_bytes_with_nul_unchecked(b"fs_main\0") });

        let shader_stages = [vert_stage, frag_stage];

        // Pipeline States
        let vertex_input_state = vk::PipelineVertexInputStateCreateInfo::default()
            .vertex_binding_descriptions(std::slice::from_ref(&vk::VertexInputBindingDescription {
                binding: 0,
                stride: std::mem::size_of::<Vertex>() as u32,
                input_rate: vk::VertexInputRate::VERTEX,
            }))
            .vertex_attribute_descriptions(&[
                vk::VertexInputAttributeDescription {
                    location: 0,
                    binding: 0,
                    format: vk::Format::R32G32_SFLOAT,
                    offset: 0,
                },
                vk::VertexInputAttributeDescription {
                    location: 1,
                    binding: 0,
                    format: vk::Format::R32G32_SFLOAT,
                    offset: 8,
                },
                vk::VertexInputAttributeDescription {
                    location: 2,
                    binding: 0,
                    format: vk::Format::R32G32B32A32_SFLOAT,
                    offset: 16,
                },
            ]);

        let input_assembly = vk::PipelineInputAssemblyStateCreateInfo::default()
            .topology(vk::PrimitiveTopology::TRIANGLE_LIST)
            .primitive_restart_enable(false);

        let viewport_state = vk::PipelineViewportStateCreateInfo::default()
            .viewport_count(1)
            .scissor_count(1);

        let rasterizer = vk::PipelineRasterizationStateCreateInfo::default()
            .depth_clamp_enable(false)
            .rasterizer_discard_enable(false)
            .polygon_mode(vk::PolygonMode::FILL)
            .line_width(1.0)
            .cull_mode(vk::CullModeFlags::NONE)
            .front_face(vk::FrontFace::CLOCKWISE)
            .depth_bias_enable(false);

        let multisampling = vk::PipelineMultisampleStateCreateInfo::default()
            .sample_shading_enable(false)
            .rasterization_samples(vk::SampleCountFlags::TYPE_1);

        let color_blend_attachment = vk::PipelineColorBlendAttachmentState::default()
            .color_write_mask(
                vk::ColorComponentFlags::R
                    | vk::ColorComponentFlags::G
                    | vk::ColorComponentFlags::B
                    | vk::ColorComponentFlags::A,
            )
            .blend_enable(true)
            .src_color_blend_factor(vk::BlendFactor::SRC_ALPHA)
            .dst_color_blend_factor(vk::BlendFactor::ONE_MINUS_SRC_ALPHA)
            .color_blend_op(vk::BlendOp::ADD)
            .src_alpha_blend_factor(vk::BlendFactor::ONE)
            .dst_alpha_blend_factor(vk::BlendFactor::ZERO)
            .alpha_blend_op(vk::BlendOp::ADD);

        let color_blending = vk::PipelineColorBlendStateCreateInfo::default()
            .logic_op_enable(false)
            .attachments(std::slice::from_ref(&color_blend_attachment));

        let dynamic_states = [vk::DynamicState::VIEWPORT, vk::DynamicState::SCISSOR];
        let dynamic_state =
            vk::PipelineDynamicStateCreateInfo::default().dynamic_states(&dynamic_states);

        let pipeline_info = vk::GraphicsPipelineCreateInfo::default()
            .stages(&shader_stages)
            .vertex_input_state(&vertex_input_state)
            .input_assembly_state(&input_assembly)
            .viewport_state(&viewport_state)
            .rasterization_state(&rasterizer)
            .multisample_state(&multisampling)
            .color_blend_state(&color_blending)
            .dynamic_state(&dynamic_state)
            .layout(pipeline_layout)
            .render_pass(render_pass)
            .subpass(0);

        let pipelines = device
            .create_graphics_pipelines(vk::PipelineCache::null(), &[pipeline_info], None)
            .map_err(|e| format!("Failed to create graphics pipeline: {:?}", e))?;
        let pipeline = pipelines[0];

        // Clean up shader module
        device.destroy_shader_module(shader_module, None);

        // Create query pools for profiling (Double Buffered)
        let query_pool_info = vk::QueryPoolCreateInfo::default()
            .query_type(vk::QueryType::TIMESTAMP)
            .query_count(64);
        let qp0 = device.create_query_pool(&query_pool_info, None)
            .map_err(|e| format!("Failed to create query pool 0: {:?}", e))?;
        let qp1 = device.create_query_pool(&query_pool_info, None)
            .map_err(|e| format!("Failed to create query pool 1: {:?}", e))?;

        let props = instance.get_physical_device_properties(physical_device);
        let timestamp_period = props.limits.timestamp_period;

        // K13: Indirect Dispatch Pipeline
        let k13_wgsl = include_str!("shaders/k13_indirect.wgsl");
        let k13_spv = Self::compile_wgsl(k13_wgsl)?;
        let k13_module_info = vk::ShaderModuleCreateInfo::default().code(&k13_spv);
        let k13_module = unsafe { device.create_shader_module(&k13_module_info, None) }
            .map_err(|e| format!("Failed to create K13 shader module: {:?}", e))?;

        let k13_bindings = [
            vk::DescriptorSetLayoutBinding::default()
                .binding(0)
                .descriptor_type(vk::DescriptorType::STORAGE_BUFFER)
                .descriptor_count(1)
                .stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default()
                .binding(1)
                .descriptor_type(vk::DescriptorType::STORAGE_BUFFER)
                .descriptor_count(1)
                .stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default()
                .binding(2)
                .descriptor_type(vk::DescriptorType::STORAGE_BUFFER)
                .descriptor_count(1)
                .stage_flags(vk::ShaderStageFlags::COMPUTE),
        ];

        let k13_set_layout_info = vk::DescriptorSetLayoutCreateInfo::default().bindings(&k13_bindings);
        let k13_set_layout = unsafe { device.create_descriptor_set_layout(&k13_set_layout_info, None) }
            .map_err(|e| format!("Failed to create K13 descriptor set layout: {:?}", e))?;

        let k13_layout_info = vk::PipelineLayoutCreateInfo::default().set_layouts(std::slice::from_ref(&k13_set_layout));
        let k13_layout = unsafe { device.create_pipeline_layout(&k13_layout_info, None) }
            .map_err(|e| format!("Failed to create K13 pipeline layout: {:?}", e))?;

        let k13_stage_info = vk::PipelineShaderStageCreateInfo::default()
            .stage(vk::ShaderStageFlags::COMPUTE)
            .module(k13_module)
            .name(unsafe { CStr::from_bytes_with_nul_unchecked(b"main\0") });

        let k13_pipeline_info = vk::ComputePipelineCreateInfo::default()
            .stage(k13_stage_info)
            .layout(k13_layout);

        let k13_pipelines = unsafe { device.create_compute_pipelines(vk::PipelineCache::null(), &[k13_pipeline_info], None) }
            .map_err(|e| format!("Failed to create K13 compute pipeline: {:?}", e))?;
        let k13_pipeline = k13_pipelines[0];
        unsafe { device.destroy_shader_module(k13_module, None); }

        // Allocate and Update K13 Descriptor Set
        let k13_alloc_info = vk::DescriptorSetAllocateInfo::default()
            .descriptor_pool(descriptor_pool)
            .set_layouts(std::slice::from_ref(&k13_set_layout));
        let k13_descriptor_set = unsafe { device.allocate_descriptor_sets(&k13_alloc_info) }
            .map_err(|e| format!("Failed to allocate K13 descriptor set: {:?}", e))?[0];

        let k13_db_infos = [
            vk::DescriptorBufferInfo::default().buffer(counter_buffer).offset(0).range(vk::WHOLE_SIZE),
            vk::DescriptorBufferInfo::default().buffer(indirect_draw_buffer).offset(0).range(vk::WHOLE_SIZE),
            vk::DescriptorBufferInfo::default().buffer(indirect_dispatch_buffer).offset(0).range(vk::WHOLE_SIZE),
        ];

        let k13_writes = [
            vk::WriteDescriptorSet::default().dst_set(k13_descriptor_set).dst_binding(0).descriptor_type(vk::DescriptorType::STORAGE_BUFFER).buffer_info(&k13_db_infos[0..1]),
            vk::WriteDescriptorSet::default().dst_set(k13_descriptor_set).dst_binding(1).descriptor_type(vk::DescriptorType::STORAGE_BUFFER).buffer_info(&k13_db_infos[1..2]),
            vk::WriteDescriptorSet::default().dst_set(k13_descriptor_set).dst_binding(2).descriptor_type(vk::DescriptorType::STORAGE_BUFFER).buffer_info(&k13_db_infos[2..3]),
        ];
        unsafe { device.update_descriptor_sets(&k13_writes, &[]); }
        // K8: Visibility Pipeline
        let k8_wgsl = include_str!("shaders/k8_visibility.wgsl");
        let k8_spv = Self::compile_wgsl(k8_wgsl)?;
        let k8_module_info = vk::ShaderModuleCreateInfo::default().code(&k8_spv);
        let k8_module = unsafe { device.create_shader_module(&k8_module_info, None) }
            .map_err(|e| format!("Failed to create K8 shader module: {:?}", e))?;

        let k8_bindings = [
            vk::DescriptorSetLayoutBinding::default().binding(0).descriptor_type(vk::DescriptorType::UNIFORM_BUFFER).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default().binding(1).descriptor_type(vk::DescriptorType::STORAGE_BUFFER).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default().binding(2).descriptor_type(vk::DescriptorType::SAMPLED_IMAGE).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default().binding(3).descriptor_type(vk::DescriptorType::STORAGE_BUFFER).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default().binding(4).descriptor_type(vk::DescriptorType::STORAGE_BUFFER).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
        ];
        let k8_set_layout_info = vk::DescriptorSetLayoutCreateInfo::default().bindings(&k8_bindings);
        let k8_set_layout = unsafe { device.create_descriptor_set_layout(&k8_set_layout_info, None) }
            .map_err(|e| format!("Failed to create K8 descriptor set layout: {:?}", e))?;
        let k8_layout_info = vk::PipelineLayoutCreateInfo::default().set_layouts(std::slice::from_ref(&k8_set_layout));
        let k8_layout = unsafe { device.create_pipeline_layout(&k8_layout_info, None) }
            .map_err(|e| format!("Failed to create K8 pipeline layout: {:?}", e))?;
        let k8_stage_info = vk::PipelineShaderStageCreateInfo::default().stage(vk::ShaderStageFlags::COMPUTE).module(k8_module).name(unsafe { CStr::from_bytes_with_nul_unchecked(b"main\0") });
        let k8_pipeline_info = vk::ComputePipelineCreateInfo::default().stage(k8_stage_info).layout(k8_layout);
        let k8_pipeline = unsafe { device.create_compute_pipelines(vk::PipelineCache::null(), &[k8_pipeline_info], None) }
            .map_err(|e| format!("Failed to create K8 compute pipeline: {:?}", e))?[0];
        unsafe { device.destroy_shader_module(k8_module, None); }

        // Allocate and Update K8 Descriptor Set
        let k8_alloc_info = vk::DescriptorSetAllocateInfo::default().descriptor_pool(descriptor_pool).set_layouts(std::slice::from_ref(&k8_set_layout));
        let k8_descriptor_set = unsafe { device.allocate_descriptor_sets(&k8_alloc_info) }
            .map_err(|e| format!("Failed to allocate K8 descriptor set: {:?}", e))?[0];

        let k8_db_infos = [
            vk::DescriptorBufferInfo::default().buffer(uniform_buffer).offset(0).range(uniform_size),
            vk::DescriptorBufferInfo::default().buffer(instance_buffer).offset(0).range(vk::WHOLE_SIZE),
            vk::DescriptorBufferInfo::default().buffer(indirect_draw_buffer).offset(0).range(vk::WHOLE_SIZE),
            vk::DescriptorBufferInfo::default().buffer(counter_buffer).offset(0).range(vk::WHOLE_SIZE),
        ];
        let k8_img_info = vk::DescriptorImageInfo::default().image_view(backdrop_view).image_layout(vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL);

        let k8_writes = [
            vk::WriteDescriptorSet::default().dst_set(k8_descriptor_set).dst_binding(0).descriptor_type(vk::DescriptorType::UNIFORM_BUFFER).buffer_info(&k8_db_infos[0..1]),
            vk::WriteDescriptorSet::default().dst_set(k8_descriptor_set).dst_binding(1).descriptor_type(vk::DescriptorType::STORAGE_BUFFER).buffer_info(&k8_db_infos[1..2]),
            vk::WriteDescriptorSet::default().dst_set(k8_descriptor_set).dst_binding(2).descriptor_type(vk::DescriptorType::SAMPLED_IMAGE).image_info(std::slice::from_ref(&k8_img_info)),
            vk::WriteDescriptorSet::default().dst_set(k8_descriptor_set).dst_binding(3).descriptor_type(vk::DescriptorType::STORAGE_BUFFER).buffer_info(&k8_db_infos[2..3]),
            vk::WriteDescriptorSet::default().dst_set(k8_descriptor_set).dst_binding(4).descriptor_type(vk::DescriptorType::STORAGE_BUFFER).buffer_info(&k8_db_infos[3..4]),
        ];
        unsafe { device.update_descriptor_sets(&k8_writes, &[]); }

        // K6: Particle Pipeline
        let k6_wgsl = include_str!("shaders/k6_particle.wgsl");
        let k6_spv = Self::compile_wgsl(k6_wgsl)?;
        let k6_module_info = vk::ShaderModuleCreateInfo::default().code(&k6_spv);
        let k6_module = unsafe { device.create_shader_module(&k6_module_info, None) }
            .map_err(|e| format!("Failed to create K6 shader module: {:?}", e))?;
        let k6_bindings = [
            vk::DescriptorSetLayoutBinding::default().binding(0).descriptor_type(vk::DescriptorType::UNIFORM_BUFFER).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default().binding(1).descriptor_type(vk::DescriptorType::STORAGE_BUFFER).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default().binding(2).descriptor_type(vk::DescriptorType::STORAGE_BUFFER).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default().binding(3).descriptor_type(vk::DescriptorType::STORAGE_BUFFER).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
        ];
        let k6_set_layout_info = vk::DescriptorSetLayoutCreateInfo::default().bindings(&k6_bindings);
        let k6_set_layout = unsafe { device.create_descriptor_set_layout(&k6_set_layout_info, None) }
            .map_err(|e| format!("Failed to create K6 descriptor set layout: {:?}", e))?;
        let k6_layout_info = vk::PipelineLayoutCreateInfo::default().set_layouts(std::slice::from_ref(&k6_set_layout));
        let k6_layout = unsafe { device.create_pipeline_layout(&k6_layout_info, None) }
            .map_err(|e| format!("Failed to create K6 pipeline layout: {:?}", e))?;
        
        let k6_u_stage_info = vk::PipelineShaderStageCreateInfo::default().stage(vk::ShaderStageFlags::COMPUTE).module(k6_module).name(unsafe { CStr::from_bytes_with_nul_unchecked(b"update\0") });
        let k6_u_pipeline = unsafe { device.create_compute_pipelines(vk::PipelineCache::null(), &[vk::ComputePipelineCreateInfo::default().stage(k6_u_stage_info).layout(k6_layout)], None) }
            .map_err(|e| format!("Failed to create K6 update pipeline: {:?}", e))?[0];
        
        let k6_s_stage_info = vk::PipelineShaderStageCreateInfo::default().stage(vk::ShaderStageFlags::COMPUTE).module(k6_module).name(unsafe { CStr::from_bytes_with_nul_unchecked(b"spawn\0") });
        let k6_s_pipeline = unsafe { device.create_compute_pipelines(vk::PipelineCache::null(), &[vk::ComputePipelineCreateInfo::default().stage(k6_s_stage_info).layout(k6_layout)], None) }
            .map_err(|e| format!("Failed to create K6 spawn pipeline: {:?}", e))?[0];
        unsafe { device.destroy_shader_module(k6_module, None); }
        let k6_update_pipeline = k6_u_pipeline;
        let k6_spawn_pipeline = k6_s_pipeline;

        // Allocate and Update K6 Descriptor Set
        let k6_alloc_info = vk::DescriptorSetAllocateInfo::default().descriptor_pool(descriptor_pool).set_layouts(std::slice::from_ref(&k6_set_layout));
        let k6_descriptor_set = unsafe { device.allocate_descriptor_sets(&k6_alloc_info) }
            .map_err(|e| format!("Failed to allocate K6 descriptor set: {:?}", e))?[0];

        let k6_db_infos = [
            vk::DescriptorBufferInfo::default().buffer(uniform_buffer).offset(0).range(uniform_size),
            vk::DescriptorBufferInfo::default().buffer(particle_buffer).offset(0).range(vk::WHOLE_SIZE),
            vk::DescriptorBufferInfo::default().buffer(counter_buffer).offset(0).range(4),
            vk::DescriptorBufferInfo::default().buffer(counter_buffer).offset(4).range(4),
        ];
        let k6_writes = [
            vk::WriteDescriptorSet::default().dst_set(k6_descriptor_set).dst_binding(0).descriptor_type(vk::DescriptorType::UNIFORM_BUFFER).buffer_info(&k6_db_infos[0..1]),
            vk::WriteDescriptorSet::default().dst_set(k6_descriptor_set).dst_binding(1).descriptor_type(vk::DescriptorType::STORAGE_BUFFER).buffer_info(&k6_db_infos[1..2]),
            vk::WriteDescriptorSet::default().dst_set(k6_descriptor_set).dst_binding(2).descriptor_type(vk::DescriptorType::STORAGE_BUFFER).buffer_info(&k6_db_infos[2..3]),
            vk::WriteDescriptorSet::default().dst_set(k6_descriptor_set).dst_binding(3).descriptor_type(vk::DescriptorType::STORAGE_BUFFER).buffer_info(&k6_db_infos[3..4]),
        ];
        unsafe { device.update_descriptor_sets(&k6_writes, &[]); }

/*
        // K5: JFA SDF Pipeline
        let k5_wgsl = include_str!("shaders/k5_jfa.wgsl");
        let k5_spv = Self::compile_wgsl(k5_wgsl)?;
        let k5_module_info = vk::ShaderModuleCreateInfo::default().code(&k5_spv);
        let k5_module = unsafe { device.create_shader_module(&k5_module_info, None) }
            .map_err(|e| format!("Failed to create K5 shader module: {:?}", e))?;
        let k5_bindings = [
            vk::DescriptorSetLayoutBinding::default().binding(1).descriptor_type(vk::DescriptorType::SAMPLED_IMAGE).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default().binding(2).descriptor_type(vk::DescriptorType::SAMPLED_IMAGE).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default().binding(3).descriptor_type(vk::DescriptorType::STORAGE_IMAGE).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
        ];
        let k5_set_layout_info = vk::DescriptorSetLayoutCreateInfo::default().bindings(&k5_bindings);
        let k5_set_layout = unsafe { device.create_descriptor_set_layout(&k5_set_layout_info, None) }
            .map_err(|e| format!("Failed to create K5 descriptor set layout: {:?}", e))?;
        let k5_pc_range = vk::PushConstantRange::default().stage_flags(vk::ShaderStageFlags::COMPUTE).offset(0).size(std::mem::size_of::<JFAUniforms>() as u32);
        let k5_layout_info = vk::PipelineLayoutCreateInfo::default().set_layouts(std::slice::from_ref(&k5_set_layout)).push_constant_ranges(std::slice::from_ref(&k5_pc_range));
        let k5_layout = unsafe { device.create_pipeline_layout(&k5_layout_info, None) }
            .map_err(|e| format!("Failed to create K5 pipeline layout: {:?}", e))?;
        let k5_stage_info = vk::PipelineShaderStageCreateInfo::default().stage(vk::ShaderStageFlags::COMPUTE).module(k5_module).name(unsafe { CStr::from_bytes_with_nul_unchecked(b"main\0") });
        let k5_pipeline = unsafe { device.create_compute_pipelines(vk::PipelineCache::null(), &[vk::ComputePipelineCreateInfo::default().stage(k5_stage_info).layout(k5_layout)], None) }
            .map_err(|e| format!("Failed to create K5 pipeline: {:?}", e))?[0];
        unsafe { device.destroy_shader_module(k5_module, None); }

        // K5 Resolve Pipeline
        let k5_resolve_wgsl = include_str!("shaders/k5_resolve.wgsl");
        let k5_resolve_spv = Self::compile_wgsl(k5_resolve_wgsl)?;
        let k5_resolve_module_info = vk::ShaderModuleCreateInfo::default().code(&k5_resolve_spv);
        let k5_resolve_module = unsafe { device.create_shader_module(&k5_resolve_module_info, None) }.map_err(|e| format!("Resolve Mod: {:?}", e))?;
        
        let k5_resolve_bindings = [
            vk::DescriptorSetLayoutBinding::default().binding(1).descriptor_type(vk::DescriptorType::SAMPLED_IMAGE).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default().binding(3).descriptor_type(vk::DescriptorType::STORAGE_IMAGE).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
        ];
        let k5_resolve_set_layout = unsafe { device.create_descriptor_set_layout(&vk::DescriptorSetLayoutCreateInfo::default().bindings(&k5_resolve_bindings), None) }?;
        let k5_resolve_pc_range = vk::PushConstantRange::default().stage_flags(vk::ShaderStageFlags::COMPUTE).offset(0).size(std::mem::size_of::<JFAUniforms>() as u32);
        let k5_resolve_layout = unsafe { device.create_pipeline_layout(&vk::PipelineLayoutCreateInfo::default().set_layouts(std::slice::from_ref(&k5_resolve_set_layout)).push_constant_ranges(std::slice::from_ref(&k5_resolve_pc_range)), None) }?;
        let k5_resolve_pipeline = unsafe { device.create_compute_pipelines(vk::PipelineCache::null(), &[vk::ComputePipelineCreateInfo::default().stage(vk::PipelineShaderStageCreateInfo::default().stage(vk::ShaderStageFlags::COMPUTE).module(k5_resolve_module).name(unsafe { CStr::from_bytes_with_nul_unchecked(b"main\0") })).layout(k5_resolve_layout)], None) }?[0];
        unsafe { device.destroy_shader_module(k5_resolve_module, None); }

        let k5_resolve_descriptor_sets_vec = unsafe { device.allocate_descriptor_sets(&vk::DescriptorSetAllocateInfo::default().descriptor_pool(descriptor_pool).set_layouts(&[k5_resolve_set_layout, k5_resolve_set_layout])) }?;
        let k5_resolve_descriptor_sets = [k5_resolve_descriptor_sets_vec[0], k5_resolve_descriptor_sets_vec[1]];
        
        for i in 0..2 {
            let resolve_img_info_src = vk::DescriptorImageInfo::default().image_view(jfa_images[i].2).image_layout(vk::ImageLayout::GENERAL);
            let resolve_img_info_dst = vk::DescriptorImageInfo::default().image_view(sdf_image.2).image_layout(vk::ImageLayout::GENERAL);
            unsafe { device.update_descriptor_sets(&[
                vk::WriteDescriptorSet::default().dst_set(k5_resolve_descriptor_sets[i]).dst_binding(1).descriptor_type(vk::DescriptorType::SAMPLED_IMAGE).image_info(&[resolve_img_info_src]),
                vk::WriteDescriptorSet::default().dst_set(k5_resolve_descriptor_sets[i]).dst_binding(3).descriptor_type(vk::DescriptorType::STORAGE_IMAGE).image_info(&[resolve_img_info_dst]),
            ], &[]); }
        }
        let seed_wgsl = include_str!("shaders/seed.wgsl");
        let seed_spv = Self::compile_wgsl(seed_wgsl)?;
        let seed_module_info = vk::ShaderModuleCreateInfo::default().code(&seed_spv);
        let seed_module = unsafe { device.create_shader_module(&seed_module_info, None) }
            .map_err(|e| format!("Failed to create seed shader module: {:?}", e))?;

        let seed_render_pass_attachments = [vk::AttachmentDescription::default()
            .format(vk::Format::R32G32_SFLOAT)
            .samples(vk::SampleCountFlags::TYPE_1)
            .load_op(vk::AttachmentLoadOp::CLEAR)
            .store_op(vk::AttachmentStoreOp::STORE)
            .stencil_load_op(vk::AttachmentLoadOp::DONT_CARE)
            .stencil_store_op(vk::AttachmentStoreOp::DONT_CARE)
            .initial_layout(vk::ImageLayout::UNDEFINED)
            .final_layout(vk::ImageLayout::GENERAL)];
        
        let seed_color_attachment_ref = vk::AttachmentReference::default().attachment(0).layout(vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL);
        let seed_subpass = vk::SubpassDescription::default().pipeline_bind_point(vk::PipelineBindPoint::GRAPHICS).color_attachments(std::slice::from_ref(&seed_color_attachment_ref));
        let seed_render_pass_info = vk::RenderPassCreateInfo::default().attachments(&seed_render_pass_attachments).subpasses(std::slice::from_ref(&seed_subpass));
        let seed_render_pass = unsafe { device.create_render_pass(&seed_render_pass_info, None) }.map_err(|e| format!("Seed RP: {:?}", e))?;

        let jfa_framebuffers = [
            unsafe { device.create_framebuffer(&vk::FramebufferCreateInfo::default().render_pass(seed_render_pass).attachments(&[jfa_images[0].2]).width(width).height(height).layers(1), None) }.map_err(|e| format!("JFA FB 0: {:?}", e))?,
            unsafe { device.create_framebuffer(&vk::FramebufferCreateInfo::default().render_pass(seed_render_pass).attachments(&[jfa_images[1].2]).width(width).height(height).layers(1), None) }.map_err(|e| format!("JFA FB 1: {:?}", e))?,
        ];

        let seed_layout_info = vk::PipelineLayoutCreateInfo::default().set_layouts(&[descriptor_set_layout]).push_constant_ranges(&[vk::PushConstantRange::default().stage_flags(vk::ShaderStageFlags::VERTEX | vk::ShaderStageFlags::FRAGMENT).offset(0).size(std::mem::size_of::<PushConstants>() as u32)]);
        let seed_layout = unsafe { device.create_pipeline_layout(&seed_layout_info, None) }.map_err(|e| format!("Seed Layout: {:?}", e))?;

        // Pipeline state... (I'll keep it minimal)
        let seed_stage_infos = [
            vk::PipelineShaderStageCreateInfo::default().stage(vk::ShaderStageFlags::VERTEX).module(seed_module).name(unsafe { CStr::from_bytes_with_nul_unchecked(b"vs_main\0") }),
            vk::PipelineShaderStageCreateInfo::default().stage(vk::ShaderStageFlags::FRAGMENT).module(seed_module).name(unsafe { CStr::from_bytes_with_nul_unchecked(b"fs_main\0") }),
        ];
        // Reuse vertex input from main pipeline or similar
        // For brevity, I'll assume we use the same Vertex struct
        // Pipeline state for Seed Seeding (Mirror main pipeline but for RG32_SFLOAT)
        let vi_info = vk::PipelineVertexInputStateCreateInfo::default(); // Using unit quad in VS, no buffers needed for position if hardcoded, but we use Vertex for simplicity
        let ia_info = vk::PipelineInputAssemblyStateCreateInfo::default().topology(vk::PrimitiveTopology::TRIANGLE_LIST);
        let vp_info = vk::PipelineViewportStateCreateInfo::default().viewport_count(1).scissor_count(1);
        let rs_info = vk::PipelineRasterizationStateCreateInfo::default().line_width(1.0).cull_mode(vk::CullModeFlags::NONE).front_face(vk::FrontFace::COUNTER_CLOCKWISE);
        let ms_info = vk::PipelineMultisampleStateCreateInfo::default().rasterization_samples(vk::SampleCountFlags::TYPE_1);
        let ds_info = vk::PipelineDepthStencilStateCreateInfo::default().depth_test_enable(false);
        let cb_attach = vk::PipelineColorBlendAttachmentState::default().color_write_mask(vk::ColorComponentFlags::RGBA);
        let cb_info = vk::PipelineColorBlendStateCreateInfo::default().attachments(std::slice::from_ref(&cb_attach));

        let seed_pipeline_info = vk::GraphicsPipelineCreateInfo::default()
            .stages(&seed_stage_infos)
            .vertex_input_state(&vi_info)
            .input_assembly_state(&ia_info)
            .viewport_state(&vp_info)
            .rasterization_state(&rs_info)
            .multisample_state(&ms_info)
            .depth_stencil_state(&ds_info)
            .color_blend_state(&cb_info)
            .layout(seed_layout)
            .render_pass(seed_render_pass)
            .subpass(0);

        let seed_pipeline = unsafe { device.create_graphics_pipelines(vk::PipelineCache::null(), &[seed_pipeline_info], None) }.map_err(|e| format!("Seed Pipe: {:?}", e))?[0];
        unsafe { device.destroy_shader_module(seed_module, None); }
*/
/*
        let k5_alloc_info = vk::DescriptorSetAllocateInfo::default().descriptor_pool(descriptor_pool).set_layouts(&[k5_set_layout, k5_set_layout]);
        let k5_descriptor_sets_vec = unsafe { device.allocate_descriptor_sets(&k5_alloc_info) }
            .map_err(|e| format!("Failed to allocate K5 descriptor sets: {:?}", e))?;
        let k5_descriptor_sets = [k5_descriptor_sets_vec[0], k5_descriptor_sets_vec[1]];

        for i in 0..2 {
            let src_idx = i;
            let dst_idx = (i + 1) % 2;
            
            let img_info_src_0 = vk::DescriptorImageInfo::default().image_view(jfa_images[src_idx].2).image_layout(vk::ImageLayout::GENERAL);
            let img_info_src_1 = vk::DescriptorImageInfo::default().image_view(jfa_images[dst_idx].2).image_layout(vk::ImageLayout::GENERAL);
            let img_info_dst = vk::DescriptorImageInfo::default().image_view(jfa_images[dst_idx].2).image_layout(vk::ImageLayout::GENERAL);
            let db_info = vk::DescriptorBufferInfo::default().buffer(uniform_buffer).offset(0).range(uniform_size);

            let k5_writes = [
                vk::WriteDescriptorSet::default().dst_set(k5_descriptor_sets[i]).dst_binding(1).descriptor_type(vk::DescriptorType::SAMPLED_IMAGE).image_info(&[img_info_src_0]),
                vk::WriteDescriptorSet::default().dst_set(k5_descriptor_sets[i]).dst_binding(2).descriptor_type(vk::DescriptorType::SAMPLED_IMAGE).image_info(&[img_info_src_1]),
                vk::WriteDescriptorSet::default().dst_set(k5_descriptor_sets[i]).dst_binding(3).descriptor_type(vk::DescriptorType::STORAGE_IMAGE).image_info(&[img_info_dst]),
            ];
            unsafe { device.update_descriptor_sets(&k5_writes, &[]); }
        }
*/


/*
        // K4: Cinematic Resolver Pipeline
        let k4_wgsl = include_str!("shaders/k4_resolver.wgsl");
        let k4_spv = Self::compile_wgsl(k4_wgsl)?;
        let k4_module_info = vk::ShaderModuleCreateInfo::default().code(&k4_spv);
        let k4_module = unsafe { device.create_shader_module(&k4_module_info, None) }
            .map_err(|e| format!("Failed to create K4 shader module: {:?}", e))?;
        let k4_bindings = [
            vk::DescriptorSetLayoutBinding::default().binding(0).descriptor_type(vk::DescriptorType::UNIFORM_BUFFER).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default().binding(1).descriptor_type(vk::DescriptorType::SAMPLED_IMAGE).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default().binding(2).descriptor_type(vk::DescriptorType::SAMPLED_IMAGE).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default().binding(3).descriptor_type(vk::DescriptorType::SAMPLED_IMAGE).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default().binding(4).descriptor_type(vk::DescriptorType::SAMPLER).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
            vk::DescriptorSetLayoutBinding::default().binding(5).descriptor_type(vk::DescriptorType::STORAGE_IMAGE).descriptor_count(1).stage_flags(vk::ShaderStageFlags::COMPUTE),
        ];
        let k4_set_layout_info = vk::DescriptorSetLayoutCreateInfo::default().bindings(&k4_bindings);
        let k4_set_layout = unsafe { device.create_descriptor_set_layout(&k4_set_layout_info, None) }
            .map_err(|e| format!("Failed to create K4 descriptor set layout: {:?}", e))?;
        let k4_layout_info = vk::PipelineLayoutCreateInfo::default().set_layouts(std::slice::from_ref(&k4_set_layout));
        let k4_layout = unsafe { device.create_pipeline_layout(&k4_layout_info, None) }
            .map_err(|e| format!("Failed to create K4 pipeline layout: {:?}", e))?;
        let k4_stage_info = vk::PipelineShaderStageCreateInfo::default().stage(vk::ShaderStageFlags::COMPUTE).module(k4_module).name(unsafe { CStr::from_bytes_with_nul_unchecked(b"main\0") });
        let k4_pipeline = unsafe { device.create_compute_pipelines(vk::PipelineCache::null(), &[vk::ComputePipelineCreateInfo::default().stage(k4_stage_info).layout(k4_layout)], None) }
            .map_err(|e| format!("Failed to create K4 pipeline: {:?}", e))?[0];
        unsafe { device.destroy_shader_module(k4_module, None); }

        // Allocate and Update K4 Descriptor Set
        let k4_alloc_info = vk::DescriptorSetAllocateInfo::default().descriptor_pool(descriptor_pool).set_layouts(std::slice::from_ref(&k4_set_layout));
        let k4_descriptor_set = unsafe { device.allocate_descriptor_sets(&k4_alloc_info) }
            .map_err(|e| format!("Failed to allocate K4 descriptor set: {:?}", e))?[0];

        let k4_db_info = vk::DescriptorBufferInfo::default().buffer(uniform_buffer).offset(0).range(uniform_size);
        let k4_img_infos = [
            vk::DescriptorImageInfo::default().image_view(backdrop_view).image_layout(vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL), // Input (previous frame)
            vk::DescriptorImageInfo::default().image_view(backdrop_view).image_layout(vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL), // Blur/Bloom Input
            vk::DescriptorImageInfo::default().image_view(backdrop_view).image_layout(vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL), // History Buffer
            vk::DescriptorImageInfo::default().sampler(sampler),
            vk::DescriptorImageInfo::default().image_view(backdrop_view).image_layout(vk::ImageLayout::GENERAL), // Final Output
        ];

        let k4_writes = [
            vk::WriteDescriptorSet::default().dst_set(k4_descriptor_set).dst_binding(0).descriptor_type(vk::DescriptorType::UNIFORM_BUFFER).buffer_info(std::slice::from_ref(&k4_db_info)),
            vk::WriteDescriptorSet::default().dst_set(k4_descriptor_set).dst_binding(1).descriptor_type(vk::DescriptorType::SAMPLED_IMAGE).image_info(&k4_img_infos[0..1]),
            vk::WriteDescriptorSet::default().dst_set(k4_descriptor_set).dst_binding(2).descriptor_type(vk::DescriptorType::SAMPLED_IMAGE).image_info(&k4_img_infos[1..2]),
            vk::WriteDescriptorSet::default().dst_set(k4_descriptor_set).dst_binding(3).descriptor_type(vk::DescriptorType::SAMPLED_IMAGE).image_info(&k4_img_infos[2..3]),
            vk::WriteDescriptorSet::default().dst_set(k4_descriptor_set).dst_binding(4).descriptor_type(vk::DescriptorType::SAMPLER).image_info(&k4_img_infos[3..4]),
            vk::WriteDescriptorSet::default().dst_set(k4_descriptor_set).dst_binding(5).descriptor_type(vk::DescriptorType::STORAGE_IMAGE).image_info(&k4_img_infos[4..5]),
        ];
        unsafe { device.update_descriptor_sets(&k4_writes, &[]); }
*/

        Ok(Self {
            _entry: entry,
            instance,
            physical_device,
            device,
            graphics_queue,
            command_pool,
            command_buffer,
            render_pass,
            render_pass_load,
            pipeline_layout,
            pipeline,
            descriptor_set_layout,
            descriptor_pool,
            surface_loader,
            swapchain_loader,
            surface,
            swapchain,
            swapchain_images,
            swapchain_image_views,
            framebuffers,
            vertex_buffer,
            vertex_memory,
            uniform_buffer,
            uniform_memory,
            font_texture,
            font_texture_memory,
            font_texture_view,
            sampler,
            descriptor_set,
            image_available_semaphore,
            render_finished_semaphore,
            in_flight_fence,

            // Compute Pipelines
            k13_pipeline,
            k13_layout,
            k8_pipeline,
            k8_layout,
            k6_update_pipeline,
            k6_spawn_pipeline,
            k6_layout,
            k5_pipeline,
            k5_layout,
            k4_pipeline,
            k4_layout,

            k13_descriptor_set,
            k8_descriptor_set,
            k6_descriptor_set,
            k5_descriptor_sets,
            k4_descriptor_set,

            // Compute Storage Buffers
            indirect_dispatch_buffer,
            indirect_dispatch_memory,
            indirect_draw_buffer,
            indirect_draw_memory,
            counter_buffer,
            counter_memory,
            instance_buffer,
            instance_memory,
            particle_buffer,
            particle_memory,
            counter_readback_buffer,
            counter_readback_memory,

            width,
            height,
            start_time: std::time::Instant::now(),
            last_image_index: 0,
            backdrop_image,
            backdrop_view,
            backdrop_memory,
            jfa_images,
            sdf_image,
            jfa_framebuffers,
            seed_render_pass,
            seed_pipeline,
            seed_layout,
            k5_resolve_pipeline,
            k5_resolve_layout,
            k5_resolve_descriptor_sets,
            query_pools: [qp0, qp1],
            timestamp_period,
            frame_index: 0,
        })
    }

    #[cfg(not(target_os = "windows"))]
    pub unsafe fn new(
        _hwnd: *mut std::ffi::c_void,
        _hinstance: *mut std::ffi::c_void,
        _width: u32,
        _height: u32,
    ) -> Result<Self, String> {
        Err("Vulkan backend Windows surface not available on this platform".to_string())
    }

    fn compile_wgsl(wgsl: &str) -> Result<Vec<u32>, String> {
        #[cfg(feature = "vulkan")]
        {
            let module = naga::front::wgsl::parse_str(wgsl)
                .map_err(|e| format!("WGSL Parse Error: {:?}", e))?;
            
            let mut validator = naga::valid::Validator::new(
                naga::valid::ValidationFlags::all(),
                naga::valid::Capabilities::all(),
            );
            
            let info = validator.validate(&module)
                .map_err(|e| format!("WGSL Validation Error: {:?}", e))?;
            
            let spirv = naga::back::spv::write_vec(
                &module,
                &info,
                &naga::back::spv::Options {
                    lang_version: (1, 3),
                    flags: naga::back::spv::WriterFlags::empty(),
                    ..naga::back::spv::Options::default()
                },
                None,
            ).map_err(|e| format!("SPIR-V Export Error: {:?}", e))?;
            
            Ok(spirv)
        }
        #[cfg(not(feature = "vulkan"))]
        {
            let _ = wgsl;
            Err("Vulkan feature not enabled".to_string())
        }
    }

    unsafe fn create_buffer(
        device: &ash::Device,
        instance: &ash::Instance,
        physical_device: vk::PhysicalDevice,
        size: vk::DeviceSize,
        usage: vk::BufferUsageFlags,
        properties: vk::MemoryPropertyFlags,
    ) -> Result<(vk::Buffer, vk::DeviceMemory), String> {
        let buffer_info = vk::BufferCreateInfo::default()
            .size(size)
            .usage(usage)
            .sharing_mode(vk::SharingMode::EXCLUSIVE);

        let buffer = device
            .create_buffer(&buffer_info, None)
            .map_err(|e| format!("Failed to create buffer: {:?}", e))?;

        let mem_requirements = device.get_buffer_memory_requirements(buffer);
        let mem_properties = instance.get_physical_device_memory_properties(physical_device);

        let memory_type = Self::find_memory_type(
            mem_properties,
            mem_requirements.memory_type_bits,
            properties,
        )?;

        let alloc_info = vk::MemoryAllocateInfo::default()
            .allocation_size(mem_requirements.size)
            .memory_type_index(memory_type);

        let memory = device
            .allocate_memory(&alloc_info, None)
            .map_err(|e| format!("Failed to allocate buffer memory: {:?}", e))?;

        device
            .bind_buffer_memory(buffer, memory, 0)
            .map_err(|e| format!("Failed to bind buffer memory: {:?}", e))?;

        Ok((buffer, memory))
    }

    unsafe fn create_texture(
        device: &ash::Device,
        instance: &ash::Instance,
        physical_device: vk::PhysicalDevice,
        width: u32,
        height: u32,
        data: Option<&[u8]>,
        format: vk::Format,
        usage: vk::ImageUsageFlags,
        mip_levels: u32,
    ) -> Result<(vk::Image, vk::DeviceMemory, vk::ImageView), String> {
        let image_info = vk::ImageCreateInfo::default()
            .image_type(vk::ImageType::TYPE_2D)
            .format(format)
            .extent(vk::Extent3D {
                width,
                height,
                depth: 1,
            })
            .mip_levels(mip_levels)
            .array_layers(1)
            .samples(vk::SampleCountFlags::TYPE_1)
            .tiling(vk::ImageTiling::OPTIMAL)
            .usage(usage | vk::ImageUsageFlags::SAMPLED)
            .sharing_mode(vk::SharingMode::EXCLUSIVE)
            .initial_layout(vk::ImageLayout::UNDEFINED);

        let image = device
            .create_image(&image_info, None)
            .map_err(|e| format!("Failed to create image: {:?}", e))?;

        let mem_requirements = device.get_image_memory_requirements(image);
        let mem_properties = instance.get_physical_device_memory_properties(physical_device);

        let memory_type = Self::find_memory_type(
            mem_properties,
            mem_requirements.memory_type_bits,
            vk::MemoryPropertyFlags::DEVICE_LOCAL,
        )?;

        let alloc_info = vk::MemoryAllocateInfo::default()
            .allocation_size(mem_requirements.size)
            .memory_type_index(memory_type);

        let memory = device
            .allocate_memory(&alloc_info, None)
            .map_err(|e| format!("Failed to allocate image memory: {:?}", e))?;

        device
            .bind_image_memory(image, memory, 0)
            .map_err(|e| format!("Failed to bind image memory: {:?}", e))?;

        if let Some(_data) = data {
             // For now, font texture is 1 canal. 
             // Logic for data upload would be here (staging buffer etc)
             // But since we only have font texture using it and it's updated later, 
             // we can skip initial data upload for now if it's None.
             // Existing code just created it with zeros.
        }

        let view_info = vk::ImageViewCreateInfo::default()
            .image(image)
            .view_type(vk::ImageViewType::TYPE_2D)
            .format(format)
            .components(vk::ComponentMapping {
                r: vk::ComponentSwizzle::IDENTITY,
                g: vk::ComponentSwizzle::IDENTITY,
                b: vk::ComponentSwizzle::IDENTITY,
                a: vk::ComponentSwizzle::IDENTITY,
            })
            .subresource_range(vk::ImageSubresourceRange {
                aspect_mask: vk::ImageAspectFlags::COLOR,
                base_mip_level: 0,
                level_count: mip_levels,
                base_array_layer: 0,
                layer_count: 1,
            });

        let view = device
            .create_image_view(&view_info, None)
            .map_err(|e| format!("Failed to create image view: {:?}", e))?;

        Ok((image, memory, view))
    }

    fn find_memory_type(
        mem_properties: vk::PhysicalDeviceMemoryProperties,
        type_filter: u32,
        properties: vk::MemoryPropertyFlags,
    ) -> Result<u32, String> {
        for i in 0..mem_properties.memory_type_count {
            if (type_filter & (1 << i)) != 0
                && mem_properties.memory_types[i as usize]
                    .property_flags
                    .contains(properties)
            {
                return Ok(i);
            }
        }
        Err("Failed to find suitable memory type".to_string())
    }

    fn ortho(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32) -> [[f32; 4]; 4] {
        let tx = -(right + left) / (right - left);
        let ty = -(top + bottom) / (top - bottom);
        let tz = -(far + near) / (far - near);

        [
            [2.0 / (right - left), 0.0, 0.0, 0.0],
            [0.0, 2.0 / (top - bottom), 0.0, 0.0],
            [0.0, 0.0, -2.0 / (far - near), 0.0],
            [tx, ty, tz, 1.0],
        ]
    }

    #[allow(dead_code)]
    fn quad_vertices(pos: Vec2, size: Vec2, color: ColorF) -> [Vertex; 6] {
        Self::quad_vertices_uv(pos, size, [0.0, 0.0, 1.0, 1.0], color)
    }

    fn quad_vertices_uv(pos: Vec2, size: Vec2, uv: [f32; 4], color: ColorF) -> [Vertex; 6] {
        let (x0, y0) = (pos.x, pos.y);
        let (x1, y1) = (pos.x + size.x, pos.y + size.y);
        let c = [color.r, color.g, color.b, color.a];
        let (u0, v0, u1, v1) = (uv[0], uv[1], uv[2], uv[3]);

        [
            Vertex {
                pos: [x0, y0],
                uv: [u0, v0],
                color: c,
            },
            Vertex {
                pos: [x0, y1],
                uv: [u0, v1],
                color: c,
            },
            Vertex {
                pos: [x1, y1],
                uv: [u1, v1],
                color: c,
            },
            Vertex {
                pos: [x0, y0],
                uv: [u0, v0],
                color: c,
            },
            Vertex {
                pos: [x1, y1],
                uv: [u1, v1],
                color: c,
            },
            Vertex {
                pos: [x1, y0],
                uv: [u1, v0],
                color: c,
            },
        ]
    }

    unsafe fn cmd_transition_image_layout(
        &self,
        command_buffer: vk::CommandBuffer,
        image: vk::Image,
        old_layout: vk::ImageLayout,
        new_layout: vk::ImageLayout,
        mip_levels: u32,
    ) {
        let (src_access, dst_access, src_stage, dst_stage) = match (old_layout, new_layout) {
            (vk::ImageLayout::UNDEFINED, vk::ImageLayout::TRANSFER_DST_OPTIMAL) => (
                vk::AccessFlags::empty(),
                vk::AccessFlags::TRANSFER_WRITE,
                vk::PipelineStageFlags::TOP_OF_PIPE,
                vk::PipelineStageFlags::TRANSFER,
            ),
            (vk::ImageLayout::TRANSFER_DST_OPTIMAL, vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL) => (
                vk::AccessFlags::TRANSFER_WRITE,
                vk::AccessFlags::SHADER_READ,
                vk::PipelineStageFlags::TRANSFER,
                vk::PipelineStageFlags::FRAGMENT_SHADER,
            ),
            (vk::ImageLayout::TRANSFER_DST_OPTIMAL, vk::ImageLayout::TRANSFER_SRC_OPTIMAL) => (
                vk::AccessFlags::TRANSFER_WRITE,
                vk::AccessFlags::TRANSFER_READ,
                vk::PipelineStageFlags::TRANSFER,
                vk::PipelineStageFlags::TRANSFER,
            ),
            (vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL, vk::ImageLayout::TRANSFER_SRC_OPTIMAL) => (
                vk::AccessFlags::COLOR_ATTACHMENT_WRITE,
                vk::AccessFlags::TRANSFER_READ,
                vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT,
                vk::PipelineStageFlags::TRANSFER,
            ),
            (vk::ImageLayout::TRANSFER_SRC_OPTIMAL, vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL) => (
                vk::AccessFlags::TRANSFER_READ,
                vk::AccessFlags::COLOR_ATTACHMENT_WRITE,
                vk::PipelineStageFlags::TRANSFER,
                vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT,
            ),
            _ => (
                vk::AccessFlags::MEMORY_READ | vk::AccessFlags::MEMORY_WRITE,
                vk::AccessFlags::MEMORY_READ | vk::AccessFlags::MEMORY_WRITE,
                vk::PipelineStageFlags::ALL_COMMANDS,
                vk::PipelineStageFlags::ALL_COMMANDS,
            ),
        };

        let barrier = vk::ImageMemoryBarrier::default()
            .old_layout(old_layout)
            .new_layout(new_layout)
            .src_access_mask(src_access)
            .dst_access_mask(dst_access)
            .image(image)
            .subresource_range(vk::ImageSubresourceRange {
                aspect_mask: vk::ImageAspectFlags::COLOR,
                base_mip_level: 0,
                level_count: mip_levels,
                base_array_layer: 0,
                layer_count: 1,
            });

        self.device.cmd_pipeline_barrier(
            command_buffer,
            src_stage,
            dst_stage,
            vk::DependencyFlags::empty(),
            &[],
            &[],
            &[barrier],
        );
    }

    unsafe fn cmd_generate_mipmaps(
        &self,
        command_buffer: vk::CommandBuffer,
        image: vk::Image,
        width: u32,
        height: u32,
        mip_levels: u32,
    ) {
        let mut mip_width = width as i32;
        let mut mip_height = height as i32;

        for i in 1..mip_levels {
            // Transition level i-1 to TRANSFER_SRC
            let barrier_src = vk::ImageMemoryBarrier::default()
                .old_layout(vk::ImageLayout::TRANSFER_DST_OPTIMAL)
                .new_layout(vk::ImageLayout::TRANSFER_SRC_OPTIMAL)
                .src_access_mask(vk::AccessFlags::TRANSFER_WRITE)
                .dst_access_mask(vk::AccessFlags::TRANSFER_READ)
                .image(image)
                .subresource_range(vk::ImageSubresourceRange {
                    aspect_mask: vk::ImageAspectFlags::COLOR,
                    base_mip_level: i - 1,
                    level_count: 1,
                    base_array_layer: 0,
                    layer_count: 1,
                });

            self.device.cmd_pipeline_barrier(
                command_buffer,
                vk::PipelineStageFlags::TRANSFER,
                vk::PipelineStageFlags::TRANSFER,
                vk::DependencyFlags::empty(),
                &[],
                &[],
                &[barrier_src],
            );

            let blit = vk::ImageBlit::default()
                .src_offsets([
                    vk::Offset3D { x: 0, y: 0, z: 0 },
                    vk::Offset3D {
                        x: mip_width,
                        y: mip_height,
                        z: 1,
                    },
                ])
                .src_subresource(vk::ImageSubresourceLayers {
                    aspect_mask: vk::ImageAspectFlags::COLOR,
                    mip_level: i - 1,
                    base_array_layer: 0,
                    layer_count: 1,
                })
                .dst_offsets([
                    vk::Offset3D { x: 0, y: 0, z: 0 },
                    vk::Offset3D {
                        x: if mip_width > 1 { mip_width / 2 } else { 1 },
                        y: if mip_height > 1 { mip_height / 2 } else { 1 },
                        z: 1,
                    },
                ])
                .dst_subresource(vk::ImageSubresourceLayers {
                    aspect_mask: vk::ImageAspectFlags::COLOR,
                    mip_level: i,
                    base_array_layer: 0,
                    layer_count: 1,
                });

            self.device.cmd_blit_image(
                command_buffer,
                image,
                vk::ImageLayout::TRANSFER_SRC_OPTIMAL,
                image,
                vk::ImageLayout::TRANSFER_DST_OPTIMAL,
                &[blit],
                vk::Filter::LINEAR,
            );

            // Transition level i-1 to SHADER_READ
            let barrier_read = vk::ImageMemoryBarrier::default()
                .old_layout(vk::ImageLayout::TRANSFER_SRC_OPTIMAL)
                .new_layout(vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL)
                .src_access_mask(vk::AccessFlags::TRANSFER_READ)
                .dst_access_mask(vk::AccessFlags::SHADER_READ)
                .image(image)
                .subresource_range(vk::ImageSubresourceRange {
                    aspect_mask: vk::ImageAspectFlags::COLOR,
                    base_mip_level: i - 1,
                    level_count: 1,
                    base_array_layer: 0,
                    layer_count: 1,
                });

            self.device.cmd_pipeline_barrier(
                command_buffer,
                vk::PipelineStageFlags::TRANSFER,
                vk::PipelineStageFlags::FRAGMENT_SHADER,
                vk::DependencyFlags::empty(),
                &[],
                &[],
                &[barrier_read],
            );

            if mip_width > 1 { mip_width /= 2; }
            if mip_height > 1 { mip_height /= 2; }
        }

        // Final level transition
        let barrier_final = vk::ImageMemoryBarrier::default()
            .old_layout(vk::ImageLayout::TRANSFER_DST_OPTIMAL)
            .new_layout(vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL)
            .src_access_mask(vk::AccessFlags::TRANSFER_WRITE)
            .dst_access_mask(vk::AccessFlags::SHADER_READ)
            .image(image)
            .subresource_range(vk::ImageSubresourceRange {
                aspect_mask: vk::ImageAspectFlags::COLOR,
                base_mip_level: mip_levels - 1,
                level_count: 1,
                base_array_layer: 0,
                layer_count: 1,
            });

        self.device.cmd_pipeline_barrier(
            command_buffer,
            vk::PipelineStageFlags::TRANSFER,
            vk::PipelineStageFlags::FRAGMENT_SHADER,
            vk::DependencyFlags::empty(),
            &[],
            &[],
            &[barrier_final],
        );
    }

    unsafe fn cmd_capture_backdrop(
        &self,
        command_buffer: vk::CommandBuffer,
        swapchain_image: vk::Image,
    ) {
        // 1. Transition swapchain to TRANSFER_SRC
        self.cmd_transition_image_layout(
            command_buffer,
            swapchain_image,
            vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL,
            vk::ImageLayout::TRANSFER_SRC_OPTIMAL,
            1,
        );

        // 2. Transition backdrop to TRANSFER_DST
        self.cmd_transition_image_layout(
            command_buffer,
            self.backdrop_image,
            vk::ImageLayout::UNDEFINED,
            vk::ImageLayout::TRANSFER_DST_OPTIMAL,
            6, // 6 mip levels
        );

        // 3. Blit image (Full Screen to Backdrop)
        let blit = vk::ImageBlit::default()
            .src_offsets([
                vk::Offset3D { x: 0, y: 0, z: 0 },
                vk::Offset3D {
                    x: self.width as i32,
                    y: self.height as i32,
                    z: 1,
                },
            ])
            .src_subresource(vk::ImageSubresourceLayers {
                aspect_mask: vk::ImageAspectFlags::COLOR,
                mip_level: 0,
                base_array_layer: 0,
                layer_count: 1,
            })
            .dst_offsets([
                vk::Offset3D { x: 0, y: 0, z: 0 },
                vk::Offset3D {
                    x: self.width as i32,
                    y: self.height as i32,
                    z: 1,
                },
            ])
            .dst_subresource(vk::ImageSubresourceLayers {
                aspect_mask: vk::ImageAspectFlags::COLOR,
                mip_level: 0,
                base_array_layer: 0,
                layer_count: 1,
            });

        self.device.cmd_blit_image(
            command_buffer,
            swapchain_image,
            vk::ImageLayout::TRANSFER_SRC_OPTIMAL,
            self.backdrop_image,
            vk::ImageLayout::TRANSFER_DST_OPTIMAL,
            &[blit],
            vk::Filter::LINEAR,
        );

        // 4. Generate Mipmaps (transitions to SHADER_READ_ONLY)
        self.cmd_generate_mipmaps(
            command_buffer,
            self.backdrop_image,
            self.width,
            self.height,
            6,
        );

        // 5. Transition swapchain back to COLOR_ATTACHMENT
        self.cmd_transition_image_layout(
            command_buffer,
            swapchain_image,
            vk::ImageLayout::TRANSFER_SRC_OPTIMAL,
            vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL,
            1,
        );
    }

    pub unsafe fn reset_profiler(&self, cb: vk::CommandBuffer) {
        let pool_idx = self.frame_index % 2;
        self.device.cmd_reset_query_pool(cb, self.query_pools[pool_idx], 0, 64);
    }

    pub unsafe fn write_timestamp(&self, cb: vk::CommandBuffer, index: u32) {
        let pool_idx = self.frame_index % 2;
        self.device.cmd_write_timestamp(
            cb,
            vk::PipelineStageFlags::BOTTOM_OF_PIPE,
            self.query_pools[pool_idx],
            index,
        );
    }

    pub fn get_vulkan_stats(&self) -> (Vec<u64>, f32) {
        // Return results from the PREVIOUS frame (N-1) to avoid stalling
        if self.frame_index == 0 {
            return (vec![0u64; 64], self.timestamp_period);
        }

        let read_idx = (self.frame_index + 1) % 2; 
        
        let mut results = vec![0u64; 64];
        let pool = self.query_pools[read_idx];
        
        unsafe {
            let res = self.device.get_query_pool_results(
                pool,
                0,
                &mut results,
                vk::QueryResultFlags::TYPE_64,
            );
            
            if res.is_err() {
                 return (vec![0u64; 64], self.timestamp_period);
            }
        }
        (results, self.timestamp_period)
    fn check_gpu_sanity(&self) {
        unsafe {
            let ptr = self.device.map_memory(self.counter_readback_memory, 0, 1024, vk::MemoryMapFlags::empty()).unwrap();
            let counters = std::slice::from_raw_parts(ptr as *const u32, 256);
            
            // Layout:
            // 0: visible instances
            // 1: indirect dispatch X
            // 8: start of error counters
            // 16: start of sanity flags (bitmask)
            
            let visible_count = counters[0];
            let error_count = counters[8];
            let sanity_flags = counters[16];

            if error_count > 0 || sanity_flags != 0 {
                eprintln!("âš ï¸ GPU SANITY ALERT [Frame {}]: Errors={}, Flags=0x{:08X}, Visible={}", self.frame_index, error_count, sanity_flags, visible_count);
                if error_count > 0 {
                    eprintln!("  - Total GPU detected errors: {}", error_count);
                }
                if sanity_flags & 0x1 != 0 { eprintln!("  - FLAG: K8 Visibility output empty while Input was not."); }
                if sanity_flags & 0x2 != 0 { eprintln!("  - FLAG: K13 Indirect generation overflow."); }
            }

            self.device.unmap_memory(self.counter_readback_memory);
        }
    }
}

impl super::GraphicsBackend for VulkanBackend {
    fn name(&self) -> &str {
        "Vulkan"
    }

    fn update_font_texture(&mut self, width: u32, height: u32, data: &[u8]) {
        unsafe {
            // Create staging buffer
            let size = (width * height) as vk::DeviceSize;
            let (staging_buffer, staging_memory) = Self::create_buffer(
                &self.device,
                &self.instance,
                self.physical_device,
                size,
                vk::BufferUsageFlags::TRANSFER_SRC,
                vk::MemoryPropertyFlags::HOST_VISIBLE | vk::MemoryPropertyFlags::HOST_COHERENT,
            ).unwrap();

            // Map and copy
            let ptr = self.device.map_memory(staging_memory, 0, size, vk::MemoryMapFlags::empty()).unwrap();
            std::ptr::copy_nonoverlapping(data.as_ptr(), ptr as *mut u8, size as usize);
            self.device.unmap_memory(staging_memory);

            // Recreate image if size changed
            // For now, assume size is compatible with existing image (1024x1024 usually)
            // But let's check size
            
            // Transition to TRANSFER_DST
            let begin_info = vk::CommandBufferBeginInfo::default().flags(vk::CommandBufferUsageFlags::ONE_TIME_SUBMIT);
            self.device.begin_command_buffer(self.command_buffer, &begin_info).unwrap();

            let barrier = vk::ImageMemoryBarrier::default()
                .old_layout(vk::ImageLayout::UNDEFINED)
                .new_layout(vk::ImageLayout::TRANSFER_DST_OPTIMAL)
                .src_access_mask(vk::AccessFlags::empty())
                .dst_access_mask(vk::AccessFlags::TRANSFER_WRITE)
                .image(self.font_texture)
                .subresource_range(vk::ImageSubresourceRange {
                    aspect_mask: vk::ImageAspectFlags::COLOR,
                    base_mip_level: 0,
                    level_count: 1,
                    base_array_layer: 0,
                    layer_count: 1,
                });

            self.device.cmd_pipeline_barrier(
                self.command_buffer,
                vk::PipelineStageFlags::TOP_OF_PIPE,
                vk::PipelineStageFlags::TRANSFER,
                vk::DependencyFlags::empty(),
                &[],
                &[],
                &[barrier],
            );

            let region = vk::BufferImageCopy::default()
                .buffer_offset(0)
                .image_subresource(vk::ImageSubresourceLayers {
                    aspect_mask: vk::ImageAspectFlags::COLOR,
                    mip_level: 0,
                    base_array_layer: 0,
                    layer_count: 1,
                })
                .image_extent(vk::Extent3D { width, height, depth: 1 });

            self.device.cmd_copy_buffer_to_image(
                self.command_buffer,
                staging_buffer,
                self.font_texture,
                vk::ImageLayout::TRANSFER_DST_OPTIMAL,
                &[region],
            );

            // Transition to SHADER_READ_ONLY
            let barrier = barrier
                .old_layout(vk::ImageLayout::TRANSFER_DST_OPTIMAL)
                .new_layout(vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL)
                .src_access_mask(vk::AccessFlags::TRANSFER_WRITE)
                .dst_access_mask(vk::AccessFlags::SHADER_READ)
                .image(self.font_texture);

            self.device.cmd_pipeline_barrier(
                self.command_buffer,
                vk::PipelineStageFlags::TRANSFER,
                vk::PipelineStageFlags::FRAGMENT_SHADER,
                vk::DependencyFlags::empty(),
                &[],
                &[],
                &[barrier],
            );

            self.device.end_command_buffer(self.command_buffer).unwrap();

            // Submit and wait
            let command_buffers = [self.command_buffer];
            let submit_info = vk::SubmitInfo::default().command_buffers(&command_buffers);
            self.device.queue_submit(self.graphics_queue, &[submit_info], vk::Fence::null()).unwrap();
            self.device.queue_wait_idle(self.graphics_queue).unwrap();

            // Clean up staging resources
            self.device.destroy_buffer(staging_buffer, None);
            self.device.free_memory(staging_memory, None);
        }
    }
    fn render(&mut self, dl: &DrawList, width: u32, height: u32) {
        unsafe {
            // Wait for previous frame
            self.device
                .wait_for_fences(&[self.in_flight_fence], true, u64::MAX)
                .unwrap();
            
            self.check_gpu_sanity();

            self.device.reset_fences(&[self.in_flight_fence]).unwrap();

            // Acquire swapchain image
            let (image_index, _) = self
                .swapchain_loader
                .acquire_next_image(
                    self.swapchain,
                    u64::MAX,
                    self.image_available_semaphore,
                    vk::Fence::null(),
                )
                .unwrap();

            let instance_count = dl.commands().len() as u32;

            // Update uniform buffer
            let ubo = UniformBufferObject {
                projection: Self::ortho(0.0, width as f32, height as f32, 0.0, -1.0, 1.0),
                viewport: [width as f32, height as f32],
                time: self.start_time.elapsed().as_secs_f32(),
                _pad: 0.0,
            };
            let ptr = self
                .device
                .map_memory(
                    self.uniform_memory,
                    0,
                    std::mem::size_of::<UniformBufferObject>() as vk::DeviceSize,
                    vk::MemoryMapFlags::empty(),
                )
                .unwrap();
            std::ptr::copy_nonoverlapping(
                &ubo as *const _ as *const u8,
                ptr as *mut u8,
                std::mem::size_of::<UniformBufferObject>(),
            );
            self.device.unmap_memory(self.uniform_memory);

            // Reset and begin command buffer
            self.device
                .reset_command_buffer(self.command_buffer, vk::CommandBufferResetFlags::empty())
                .unwrap();

            let begin_info = vk::CommandBufferBeginInfo::default()
                .flags(vk::CommandBufferUsageFlags::ONE_TIME_SUBMIT);
            self.device
                .begin_command_buffer(self.command_buffer, &begin_info)
                .unwrap();

            // K11: Reset Profiler & Mark Start
            self.reset_profiler(self.command_buffer);
            self.write_timestamp(self.command_buffer, 0); // Frame Start
            
            // --- Aggressive GPU logic Phase 1 (K8, K13) ---

            if instance_count > 0 {
                // 0. Transfer DrawCommands to Instance Buffer
                let instance_size = (instance_count as usize * std::mem::size_of::<PushConstants>()) as vk::DeviceSize;
                let inst_ptr = self.device.map_memory(self.instance_memory, 0, instance_size, vk::MemoryMapFlags::empty()).unwrap();
                let inst_slice = std::slice::from_raw_parts_mut(inst_ptr as *mut PushConstants, instance_count as usize);

                for (i, cmd) in dl.commands().iter().enumerate() {
                    let mut pc = PushConstants {
                        rect: [0.0; 4],
                        radii: [0.0; 4],
                        border_color: [0.0; 4],
                        glow_color: [0.0; 4],
                        offset: [0.0; 2],
                        scale: 1.0,
                        border_width: 0.0,
                        elevation: 0.0,
                        glow_strength: 0.0,
                        lut_intensity: 0.0,
                        mode: 0,
                        is_squircle: 0,
                        _pad: [0],
                    };
                    // Fill PC based on command (Duplicated logic from main loop for now, we should unify this)
                    match cmd {
                        DrawCommand::RoundedRect { pos, size, radii, color, elevation, is_squircle, border_width, border_color, glow_strength, glow_color, .. } => {
                            pc.rect = [pos.x, pos.y, size.x, size.y]; pc.radii = *radii;
                            pc.border_color = [border_color.r, border_color.g, border_color.b, border_color.a];
                            pc.glow_color = [glow_color.r, glow_color.g, glow_color.b, glow_color.a];
                            pc.mode = 2; pc.border_width = *border_width; pc.elevation = *elevation;
                            pc.is_squircle = if *is_squircle { 1 } else { 0 }; pc.glow_strength = *glow_strength;
                        }
                        DrawCommand::Text { pos, size, uv, color } => {
                            pc.rect = [pos.x, pos.y, size.x, size.y]; pc.border_color = [color.r, color.g, color.b, color.a]; pc.mode = 1; pc.radii = *uv;
                        }
                        DrawCommand::Image { pos, size, uv, color, radii, .. } => {
                            pc.rect = [pos.x, pos.y, size.x, size.y]; pc.radii = *radii; pc.border_color = [color.r, color.g, color.b, color.a]; pc.glow_color = *uv; pc.mode = 3;
                        }
                        _ => {}
                    }
                    inst_slice[i] = pc;
                }
                self.device.unmap_memory(self.instance_memory);

                // 1. Reset counters
                self.device.cmd_fill_buffer(self.command_buffer, self.counter_buffer, 0, 1024, 0);

                // 2. Memory Barrier for instance buffer and counters
                let barriers = [
                    vk::BufferMemoryBarrier::default().src_access_mask(vk::AccessFlags::HOST_WRITE).dst_access_mask(vk::AccessFlags::SHADER_READ).buffer(self.instance_buffer).size(vk::WHOLE_SIZE),
                    vk::BufferMemoryBarrier::default().src_access_mask(vk::AccessFlags::TRANSFER_WRITE).dst_access_mask(vk::AccessFlags::SHADER_READ | vk::AccessFlags::SHADER_WRITE).buffer(self.counter_buffer).size(vk::WHOLE_SIZE),
                ];
                self.device.cmd_pipeline_barrier(self.command_buffer, vk::PipelineStageFlags::HOST | vk::PipelineStageFlags::TRANSFER, vk::PipelineStageFlags::COMPUTE_SHADER, vk::DependencyFlags::empty(), &[], &barriers, &[]);

                // 3. Dispatch K8: Visibility Culling
                self.device.cmd_bind_pipeline(self.command_buffer, vk::PipelineBindPoint::COMPUTE, self.k8_pipeline);
                self.device.cmd_bind_descriptor_sets(self.command_buffer, vk::PipelineBindPoint::COMPUTE, self.k8_layout, 0, &[self.k8_descriptor_set], &[]);
                self.device.cmd_dispatch(self.command_buffer, (instance_count + 63) / 64, 1, 1);

                // 4. Memory Barrier (K8 -> K13)
                let k8_to_k13_barrier = vk::BufferMemoryBarrier::default().src_access_mask(vk::AccessFlags::SHADER_WRITE).dst_access_mask(vk::AccessFlags::SHADER_READ).buffer(self.counter_buffer).size(vk::WHOLE_SIZE);
                self.device.cmd_pipeline_barrier(self.command_buffer, vk::PipelineStageFlags::COMPUTE_SHADER, vk::PipelineStageFlags::COMPUTE_SHADER, vk::DependencyFlags::empty(), &[], &[k8_to_k13_barrier], &[]);

                // 5. Dispatch K13: Indirect Dispatch Generator
                self.device.cmd_bind_pipeline(self.command_buffer, vk::PipelineBindPoint::COMPUTE, self.k13_pipeline);
                self.device.cmd_bind_descriptor_sets(self.command_buffer, vk::PipelineBindPoint::COMPUTE, self.k13_layout, 0, &[self.k13_descriptor_set], &[]);
                self.device.cmd_dispatch(self.command_buffer, 1, 1, 1);

                // 6. Memory Barrier (K13 -> Draw Indirect)
                let barriers = [
                    vk::BufferMemoryBarrier::default().src_access_mask(vk::AccessFlags::SHADER_WRITE).dst_access_mask(vk::AccessFlags::INDIRECT_COMMAND_READ).buffer(self.indirect_draw_buffer).size(vk::WHOLE_SIZE),
                    vk::BufferMemoryBarrier::default().src_access_mask(vk::AccessFlags::SHADER_WRITE).dst_access_mask(vk::AccessFlags::INDIRECT_COMMAND_READ).buffer(self.indirect_dispatch_buffer).size(vk::WHOLE_SIZE),
                ];
                self.device.cmd_pipeline_barrier(self.command_buffer, vk::PipelineStageFlags::COMPUTE_SHADER, vk::PipelineStageFlags::DRAW_INDIRECT, vk::DependencyFlags::empty(), &[], &barriers, &[]);
            }

            // --- End Aggressive GPU logic ---

            println!("Vulkan: Compute dispatch added, command buffer begun");

            // Begin render pass
            let clear_values = [vk::ClearValue {
                color: vk::ClearColorValue {
                    float32: [0.08, 0.08, 0.1, 1.0],
                },
            }];

            let render_pass_info = vk::RenderPassBeginInfo::default()
                .render_pass(self.render_pass)
                .framebuffer(self.framebuffers[image_index as usize])
                .render_area(vk::Rect2D {
                    offset: vk::Offset2D { x: 0, y: 0 },
                    extent: vk::Extent2D {
                        width: self.width,
                        height: self.height,
                    },
                })
                .clear_values(&clear_values);

            self.device.cmd_begin_render_pass(
                self.command_buffer,
                &render_pass_info,
                vk::SubpassContents::INLINE,
            );

            // Bind pipeline and descriptors
            if self.pipeline != vk::Pipeline::null() {
                self.device.cmd_bind_pipeline(
                    self.command_buffer,
                    vk::PipelineBindPoint::GRAPHICS,
                    self.pipeline,
                );
                self.device.cmd_bind_descriptor_sets(
                    self.command_buffer,
                    vk::PipelineBindPoint::GRAPHICS,
                    self.pipeline_layout,
                    0,
                    &[self.descriptor_set],
                    &[],
                );

                // Set viewport and scissor
                let viewport = vk::Viewport {
                    x: 0.0,
                    y: 0.0,
                    width: self.width as f32,
                    height: self.height as f32,
                    min_depth: 0.0,
                    max_depth: 1.0,
                };
                self.device
                    .cmd_set_viewport(self.command_buffer, 0, &[viewport]);

                let scissor = vk::Rect2D {
                    offset: vk::Offset2D { x: 0, y: 0 },
                    extent: vk::Extent2D {
                        width: self.width,
                        height: self.height,
                    },
                };
                self.device
                    .cmd_set_scissor(self.command_buffer, 0, &[scissor]);

                // --- GPU-driven Graphics Pass ---
                let unit_quad = [
                    Vertex { pos: [0.0, 0.0], uv: [0.0, 0.0], color: [1.0, 1.0, 1.0, 1.0] },
                    Vertex { pos: [0.0, 1.0], uv: [0.0, 1.0], color: [1.0, 1.0, 1.0, 1.0] },
                    Vertex { pos: [1.0, 1.0], uv: [1.0, 1.0], color: [1.0, 1.0, 1.0, 1.0] },
                    Vertex { pos: [0.0, 0.0], uv: [0.0, 0.0], color: [1.0, 1.0, 1.0, 1.0] },
                    Vertex { pos: [1.0, 1.0], uv: [1.0, 1.0], color: [1.0, 1.0, 1.0, 1.0] },
                    Vertex { pos: [1.0, 0.0], uv: [1.0, 0.0], color: [1.0, 1.0, 1.0, 1.0] },
                ];
                let vb_size = (unit_quad.len() * std::mem::size_of::<Vertex>()) as vk::DeviceSize;
                let vb_ptr = self.device.map_memory(self.vertex_memory, 0, vb_size, vk::MemoryMapFlags::empty()).unwrap();
                std::ptr::copy_nonoverlapping(unit_quad.as_ptr(), vb_ptr as *mut Vertex, unit_quad.len());
                self.device.unmap_memory(self.vertex_memory);

                self.device.cmd_bind_vertex_buffers(self.command_buffer, 0, &[self.vertex_buffer], &[0]);

                let pc_mode_instanced = PushConstants {
                    rect: [0.0; 4], radii: [0.0; 4], border_color: [1.0; 4], glow_color: [0.0; 4],
                    offset: [0.0; 2], scale: 1.0, border_width: 0.0, elevation: 0.0, glow_strength: 0.0,
                    lut_intensity: 0.0, mode: 0xFFFFFFFF, is_squircle: 0, _pad: [0],
                };
                self.device.cmd_push_constants(
                    self.command_buffer,
                    self.pipeline_layout,
                    vk::ShaderStageFlags::VERTEX | vk::ShaderStageFlags::FRAGMENT,
                    0,
                    std::slice::from_raw_parts(&pc_mode_instanced as *const _ as *const u8, std::mem::size_of::<PushConstants>()),
                );

                if instance_count > 0 {
                    self.device.cmd_draw_indirect(self.command_buffer, self.indirect_draw_buffer, 0, 1, std::mem::size_of::<vk::DrawIndirectCommand>() as u32);
                }
                /* Old graphics loop - deactivated
                if false {
                    let mut vertices: [Vertex; 6] = [Vertex {
                        pos: [0.0; 2],
                        uv: [0.0; 2],
                        color: [0.0; 4],
                    }; 6];
                    let mut has_draw = false;

                    let mut pc = PushConstants {
                        rect: [0.0; 4],
                        radii: [0.0; 4],
                        border_color: [0.0; 4],
                        glow_color: [0.0; 4],
                        offset: [0.0; 2],
                        scale: 1.0,
                        border_width: 0.0,
                        elevation: 0.0,
                        glow_strength: 0.0,
                        lut_intensity: 0.0,
                        mode: 0,
                        is_squircle: 0,
                        _pad: [0],
                    };

                    match cmd {
                        DrawCommand::RoundedRect {
                            pos,
                            size,
                            radii,
                            color,
                            elevation,
                            is_squircle,
                            border_width,
                            border_color,
                            glow_strength,
                            glow_color,
                            ..
                        } => {
                            let pad = if *elevation > 0.0 || *glow_strength > 0.0 {
                                100.0
                            } else {
                                0.0
                            };
                            vertices = Self::quad_vertices(
                                Vec2::new(pos.x - pad, pos.y - pad),
                                Vec2::new(size.x + pad * 2.0, size.y + pad * 2.0),
                                *color,
                            );
                            has_draw = true;
                            pc.rect = [pos.x, pos.y, size.x, size.y];
                            pc.radii = *radii;
                            pc.border_color =
                                [border_color.r, border_color.g, border_color.b, border_color.a];
                            pc.glow_color =
                                [glow_color.r, glow_color.g, glow_color.b, glow_color.a];
                            pc.mode = 2; // Shape
                            pc.border_width = *border_width;
                            pc.elevation = *elevation;
                            pc.is_squircle = if *is_squircle { 1 } else { 0 };
                            pc.glow_strength = *glow_strength;
                        }
                        DrawCommand::Text {
                            pos,
                            size,
                            uv,
                            color,
                        } => {
                            vertices = Self::quad_vertices_uv(*pos, *size, *uv, *color);
                            has_draw = true;
                            pc.mode = 1; // Text (SDF)
                        }
                        DrawCommand::Image {
                            pos,
                            size,
                            uv,
                            color,
                            radii,
                            ..
                        } => {
                            vertices = Self::quad_vertices_uv(*pos, *size, *uv, *color);
                            has_draw = true;
                            pc.rect = [pos.x, pos.y, size.x, size.y];
                            pc.radii = *radii;
                            pc.mode = 3; // Image
                        }
                        DrawCommand::Arc {
                             center,
                             radius,
                             start_angle,
                             end_angle,
                             thickness,
                             color,
                        } => {
                             let s = *radius * 2.0 + *thickness * 2.0;
                             let pos = Vec2::new(center.x - s * 0.5, center.y - s * 0.5);
                             vertices = Self::quad_vertices(pos, Vec2::new(s, s), *color);
                             has_draw = true;
                             pc.rect = [pos.x, pos.y, s, s];
                             pc.radii = [*radius, *thickness, 0.0, 0.0];
                             pc.elevation = *start_angle;
                             pc.glow_strength = *end_angle;
                             pc.mode = 6; // Arc
                        }
                         DrawCommand::BlurRect {
                            pos,
                            size,
                            radii,
                            color: _,
                            sigma,
                            is_squircle,
                         } => {
                            // High-Quality Blur requires backdrop capture
                            unsafe {
                                self.device.cmd_end_render_pass(self.command_buffer);
                                
                                self.cmd_capture_backdrop(
                                    self.command_buffer,
                                    self.swapchain_images[image_index as usize],
                                );
                                
                                // RE-START RENDER PASS (LOAD)
                                let render_pass_info = vk::RenderPassBeginInfo::default()
                                    .render_pass(self.render_pass_load)
                                    .framebuffer(self.framebuffers[image_index as usize])
                                    .render_area(vk::Rect2D {
                                        offset: vk::Offset2D { x: 0, y: 0 },
                                        extent: vk::Extent2D { width: self.width, height: self.height },
                                    });
                                self.device.cmd_begin_render_pass(self.command_buffer, &render_pass_info, vk::SubpassContents::INLINE);
                                
                                // RE-BIND PIPELINE AND DESCRIPTORS
                                self.device.cmd_bind_pipeline(self.command_buffer, vk::PipelineBindPoint::GRAPHICS, self.pipeline);
                                self.device.cmd_bind_descriptor_sets(self.command_buffer, vk::PipelineBindPoint::GRAPHICS, self.pipeline_layout, 0, &[self.descriptor_set], &[]);
                                
                                // Re-set dynamic state
                                let viewport = vk::Viewport { x: 0.0, y: 0.0, width: self.width as f32, height: self.height as f32, min_depth: 0.0, max_depth: 1.0 };
                                self.device.cmd_set_viewport(self.command_buffer, 0, &[viewport]);
                                let scissor = vk::Rect2D { offset: vk::Offset2D { x: 0, y: 0 }, extent: vk::Extent2D { width: self.width, height: self.height } };
                                self.device.cmd_set_scissor(self.command_buffer, 0, &[scissor]);
                                self.device.cmd_bind_vertex_buffers(self.command_buffer, 0, &[self.vertex_buffer], &[0]);
                            }

                            vertices = Self::quad_vertices(*pos, *size, ColorF::white());
                            has_draw = true;
                            pc.rect = [pos.x, pos.y, size.x, size.y];
                            pc.radii = *radii;
                            pc.mode = 4; // Blur
                            pc.border_width = (*sigma / 2.0).clamp(0.0, 5.0); // Abuse border_width for LOD
                            pc.is_squircle = if *is_squircle { 1 } else { 0 };
                         }
                        DrawCommand::Plot { .. } => {
                            pc.mode = 7; // Plot
                        }
                        DrawCommand::Heatmap {
                            pos,
                            size,
                            min,
                            max,
                            ..
                        } => {
                            vertices = Self::quad_vertices(*pos, *size, ColorF::white());
                            has_draw = true;
                            pc.elevation = *min;
                            pc.glow_strength = *max;
                            pc.mode = 8; // Heatmap
                        }
                        DrawCommand::Aurora { pos, size } => {
                            vertices = Self::quad_vertices(*pos, *size, ColorF::white());
                            has_draw = true;
                            pc.mode = 9; // Aurora
                        }
                        _ => {}
                    }

                    if has_draw {
                        // Copy vertices
                        unsafe {
                            let dest = vb_ptr.add(vertex_offset);
                            std::ptr::copy_nonoverlapping(vertices.as_ptr(), dest, 6);
                        }

                        // Push Constants
                        let constants_bytes = std::slice::from_raw_parts(
                            &pc as *const _ as *const u8,
                            std::mem::size_of::<PushConstants>(),
                        );

                        self.device.cmd_push_constants(
                            self.command_buffer,
                            self.pipeline_layout,
                            vk::ShaderStageFlags::VERTEX | vk::ShaderStageFlags::FRAGMENT,
                            0,
                            constants_bytes,
                        );

                        // Draw
                        self.device
                            .cmd_draw(self.command_buffer, 6, 1, vertex_offset as u32, 0);

                        vertex_offset += 6;
                    }
                }
                */
            }

            self.device.cmd_end_render_pass(self.command_buffer);

            // Sanity Readback Copy
            let copy_region = vk::BufferCopy::default().src_offset(0).dst_offset(0).size(1024);
            self.device.cmd_copy_buffer(self.command_buffer, self.counter_buffer, self.counter_readback_buffer, &[copy_region]);

            // K11: Mark End
            self.write_timestamp(self.command_buffer, 1); // Frame End

            self.device.end_command_buffer(self.command_buffer).unwrap();

            println!("Vulkan: Command buffer ended, submitting...");

            // Submit
            let wait_semaphores = [self.image_available_semaphore];
            let wait_stages = [vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT];
            let signal_semaphores = [self.render_finished_semaphore];
            let command_buffers = [self.command_buffer];

            let submit_info = vk::SubmitInfo::default()
                .wait_semaphores(&wait_semaphores)
                .wait_dst_stage_mask(&wait_stages)
                .command_buffers(&command_buffers)
                .signal_semaphores(&signal_semaphores);

            self.device
                .queue_submit(self.graphics_queue, &[submit_info], self.in_flight_fence)
                .unwrap();

            println!("Vulkan: Frame submitted");

            // Present
            let swapchains = [self.swapchain];
            let image_indices = [image_index];
            let present_info = vk::PresentInfoKHR::default()
                .wait_semaphores(&signal_semaphores)
                .swapchains(&swapchains)
                .image_indices(&image_indices);

            self.swapchain_loader
                .queue_present(self.graphics_queue, &present_info)
                .unwrap();

            self.last_image_index = image_index;

            // Increment frame index for double-buffered query pools (K11)
            self.frame_index = self.frame_index.wrapping_add(1);
        }
    }
    
    fn capture_screenshot(&mut self, path: &str) {
        unsafe {
            // Wait for GPU to finish rendering
            self.device.queue_wait_idle(self.graphics_queue).unwrap();
            
            let width = self.width;
            let height = self.height;
            let image = self.swapchain_images[self.last_image_index as usize];
            
            // Create staging buffer
            let size = (width * height * 4) as vk::DeviceSize;
            let (staging_buffer, staging_memory) = Self::create_buffer(
                &self.device,
                &self.instance,
                self.physical_device,
                size,
                vk::BufferUsageFlags::TRANSFER_DST,
                vk::MemoryPropertyFlags::HOST_VISIBLE | vk::MemoryPropertyFlags::HOST_COHERENT,
            ).unwrap();
            
            // Transition image to TRANSFER_SRC_OPTIMAL
            self.device.reset_command_buffer(self.command_buffer, vk::CommandBufferResetFlags::empty()).unwrap();
            let begin_info = vk::CommandBufferBeginInfo::default().flags(vk::CommandBufferUsageFlags::ONE_TIME_SUBMIT);
            self.device.begin_command_buffer(self.command_buffer, &begin_info).unwrap();
            
            let barrier = vk::ImageMemoryBarrier::default()
                .old_layout(vk::ImageLayout::PRESENT_SRC_KHR)
                .new_layout(vk::ImageLayout::TRANSFER_SRC_OPTIMAL)
                .src_access_mask(vk::AccessFlags::MEMORY_READ)
                .dst_access_mask(vk::AccessFlags::TRANSFER_READ)
                .image(image)
                .subresource_range(vk::ImageSubresourceRange {
                    aspect_mask: vk::ImageAspectFlags::COLOR,
                    base_mip_level: 0,
                    level_count: 1,
                    base_array_layer: 0,
                    layer_count: 1,
                });
                
            self.device.cmd_pipeline_barrier(
                self.command_buffer,
                vk::PipelineStageFlags::BOTTOM_OF_PIPE,
                vk::PipelineStageFlags::TRANSFER,
                vk::DependencyFlags::empty(),
                &[], &[], &[barrier]
            );
            
            let region = vk::BufferImageCopy::default()
                .buffer_offset(0)
                .buffer_row_length(width)
                .buffer_image_height(height)
                .image_subresource(vk::ImageSubresourceLayers {
                    aspect_mask: vk::ImageAspectFlags::COLOR,
                    mip_level: 0,
                    base_array_layer: 0,
                    layer_count: 1,
                })
                .image_extent(vk::Extent3D { width, height, depth: 1 });
                
            self.device.cmd_copy_image_to_buffer(
                self.command_buffer,
                image,
                vk::ImageLayout::TRANSFER_SRC_OPTIMAL,
                staging_buffer,
                &[region]
            );
            
            // Transition back to PRESENT_SRC_KHR
            let barrier = barrier
                .old_layout(vk::ImageLayout::TRANSFER_SRC_OPTIMAL)
                .new_layout(vk::ImageLayout::PRESENT_SRC_KHR)
                .src_access_mask(vk::AccessFlags::TRANSFER_READ)
                .dst_access_mask(vk::AccessFlags::MEMORY_READ);
                
             self.device.cmd_pipeline_barrier(
                self.command_buffer,
                vk::PipelineStageFlags::TRANSFER,
                vk::PipelineStageFlags::BOTTOM_OF_PIPE,
                vk::DependencyFlags::empty(),
                &[], &[], &[barrier]
            );
            
            self.device.end_command_buffer(self.command_buffer).unwrap();
            
            let command_buffers = [self.command_buffer];
            let submit_info = vk::SubmitInfo::default().command_buffers(&command_buffers);
            self.device.queue_submit(self.graphics_queue, &[submit_info], vk::Fence::null()).unwrap();
            self.device.queue_wait_idle(self.graphics_queue).unwrap();
            
            // Copy buffer to image crate and save
            let ptr = self.device.map_memory(staging_memory, 0, size, vk::MemoryMapFlags::empty()).unwrap();
            let slice = std::slice::from_raw_parts(ptr as *const u8, size as usize);
            
            // Swap BGRA to RGBA if needed
            let mut rgba = vec![0u8; size as usize];
            for i in (0..size as usize).step_by(4) {
                rgba[i] = slice[i + 2];     // R
                rgba[i + 1] = slice[i + 1]; // G
                rgba[i + 2] = slice[i];     // B
                rgba[i + 3] = slice[i + 3]; // A
            }
            
            image::save_buffer(
                path,
                &rgba,
                width,
                height,
                image::ColorType::Rgba8,
            ).unwrap();
            
            self.device.unmap_memory(staging_memory);
            self.device.destroy_buffer(staging_buffer, None);
            self.device.free_memory(staging_memory, None);
            
            println!("ðŸ“¸ Screenshot saved to: {}", path);
        }
    }

    fn get_profiling_results(&self) -> Option<(Vec<u64>, f32)> {
        Some(self.get_vulkan_stats())
    }
}

impl Drop for VulkanBackend {
    fn drop(&mut self) {
        unsafe {
            self.device.device_wait_idle().unwrap();

            self.device.destroy_fence(self.in_flight_fence, None);
            self.device
                .destroy_semaphore(self.render_finished_semaphore, None);
            self.device
                .destroy_semaphore(self.image_available_semaphore, None);
            self.device.destroy_query_pool(self.query_pools[0], None);
            self.device.destroy_query_pool(self.query_pools[1], None);

            self.device.destroy_sampler(self.sampler, None);
            self.device.destroy_image_view(self.font_texture_view, None);
            self.device.destroy_image(self.font_texture, None);
            self.device.free_memory(self.font_texture_memory, None);

            self.device.destroy_image_view(self.backdrop_view, None);
            self.device.destroy_image(self.backdrop_image, None);
            self.device.free_memory(self.backdrop_memory, None);

            self.device.destroy_buffer(self.uniform_buffer, None);
            self.device.free_memory(self.uniform_memory, None);
            self.device.destroy_buffer(self.vertex_buffer, None);
            self.device.free_memory(self.vertex_memory, None);

            self.device
                .destroy_descriptor_pool(self.descriptor_pool, None);
            self.device
                .destroy_descriptor_set_layout(self.descriptor_set_layout, None);

            // Destroy Compute Pipelines
            self.device.destroy_pipeline(self.k13_pipeline, None);
            self.device.destroy_pipeline_layout(self.k13_layout, None);
            self.device.destroy_pipeline(self.k8_pipeline, None);
            self.device.destroy_pipeline_layout(self.k8_layout, None);
            self.device.destroy_pipeline(self.k6_update_pipeline, None);
            self.device.destroy_pipeline(self.k6_spawn_pipeline, None);
            self.device.destroy_pipeline_layout(self.k6_layout, None);
            self.device.destroy_pipeline(self.k5_pipeline, None);
            self.device.destroy_pipeline_layout(self.k5_layout, None);
            self.device.destroy_pipeline(self.k4_pipeline, None);
            self.device.destroy_pipeline_layout(self.k4_layout, None);

            // Destroy Compute Storage Buffers
            self.device.destroy_buffer(self.indirect_dispatch_buffer, None);
            self.device.free_memory(self.indirect_dispatch_memory, None);
            self.device.destroy_buffer(self.indirect_draw_buffer, None);
            self.device.free_memory(self.indirect_draw_memory, None);
            self.device.destroy_buffer(self.counter_buffer, None);
            self.device.free_memory(self.counter_memory, None);
            self.device.destroy_buffer(self.instance_buffer, None);
            self.device.free_memory(self.instance_memory, None);
            self.device.destroy_buffer(self.particle_buffer, None);
            self.device.free_memory(self.particle_memory, None);

            if self.pipeline != vk::Pipeline::null() {
                self.device.destroy_pipeline(self.pipeline, None);
            }
            self.device
                .destroy_pipeline_layout(self.pipeline_layout, None);

            for &fb in &self.framebuffers {
                self.device.destroy_framebuffer(fb, None);
            }
            self.device.destroy_render_pass(self.render_pass, None);
            self.device.destroy_render_pass(self.render_pass_load, None);

            for &view in &self.swapchain_image_views {
                self.device.destroy_image_view(view, None);
            }
            self.swapchain_loader
                .destroy_swapchain(self.swapchain, None);

            self.device.destroy_command_pool(self.command_pool, None);
            self.device.destroy_device(None);

            self.surface_loader.destroy_surface(self.surface, None);
            self.instance.destroy_instance(None);
        }
    }
}
